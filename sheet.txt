
Q1
#include <bits/stdc++.h>

void setZeros(vector<vector<int>> &matrix)
{
	int col0=1;
	int m=matrix.size();
	int n=matrix[0].size();
	for(int i=0;i<m;i++)
	{
		for(int j=0;j<n;j++)
		{
			if(matrix[i][j]==0)
			{
				matrix[i][0]=0;
				if(j!=0)
				{
					matrix[0][j]=0;
				}
				else col0=0;
			}
		}
	}
	for(int i=1;i<m;i++)
	{
		for(int j=1;j<n;j++)
		{
            if (matrix[i][j] != 0) {
                if (matrix[i][0] == 0 || matrix[0][j] == 0)
                      matrix[i][j] = 0;
            }
        }
	}
	if(matrix[0][0]==0){
		for(int i=1;i<n;i++)
		{
			matrix[0][i]=0;
		}
	}
	if(col0==0){
		for(int i=0;i<m;i++)
		{
			matrix[i][0]=0;
		}
	}
	
	

}

Q2

#include <bits/stdc++.h>

vector<vector<long long int>> printPascal(int n) 
{
   vector<vector<long long int>> output(n);
        for(int i=0; i<n; i++){
            output[i].resize(i+1, 1);
            for(int j=1; j<i; j++){
                output[i][j] = output[i-1][j-1] + output[i-1][j];
            }
        }
        return output;
  
}

Q3
#include <bits/stdc++.h> 
vector<int> nextPermutation(vector<int> &permutation, int n)
{
    int ind=-1;
    for(int i=n-2;i>=0;i--)    
    {
           if(permutation[i+1]>permutation[i])
           {
               ind=i;
               break;
           }

    }
    if(ind==-1)
    {
        reverse(permutation.begin(),permutation.end());
        return permutation;
    }
    for(int i=n-1;i>=0;i--)
    {
        if(permutation[ind]<permutation[i])
        {
            swap(permutation[ind],permutation[i]);
            break;
        }
    }
    reverse(permutation.begin()+ind+1,permutation.end());
    return permutation;

}
Q4	
#include <bits/stdc++.h> 
long long maxSubarraySum(int arr[], int n)
{
    /*
        Don't write main().
        Don't read input, it is passed as function argument.    
        No need to print anything.
        Taking input and printing output is handled automatically.
    */
    long long maxi=LONG_MIN;
    long long sum=0;
    for(int i=0;i<n;i++)
    {
        sum+=arr[i];
        maxi=max(maxi,sum);
        if(sum<0)sum=0;
    }
    if(maxi<0) return 0;
    else return maxi;

    
}

Q5
#include <bits/stdc++.h> 
void sort012(int *arr, int n)
{
   //   Write your code here
   int low=0,mid=0,high=n-1;
   

   while(mid<=high)
   {
      
      if(arr[mid]==0)
      {
         swap(arr[low],arr[mid]);
         low++;
         mid++;
      
      }
      else if (arr[mid] == 1) {

        mid++;
      }

      else  {
        swap(arr[mid], arr[high]);
        
        high--;
      }
   }
   
}
Q6
#include <bits/stdc++.h> 
int maximumProfit(vector<int> &prices){
    // Write your code here.
    int profit=0,mini=prices[0];
    for(int i=1;i<prices.size();i++)
    {
        profit=max(profit,(prices[i]-mini));
        mini=min(prices[i],mini);
    }
    return profit;
   
}
Q7
#include <bits/stdc++.h>

void rotateMatrix(vector<vector<int>> &mat, int n, int m)
{
    int row = 0, col = 0; 
    int prev, curr; 
    int lastRow= n;
    int lastCol= m;
    while (row < lastRow && col < lastCol) 

    {  
        if (row + 1 == lastRow || col + 1 == lastCol)  break;   

        prev = mat[row + 1][col]; 
        
        for (int i = col; i < lastCol; i++) 
        { 
            curr = mat[row][i]; 
            mat[row][i] = prev; 
            prev = curr; 
        } 
        row++; 
        
        for (int i = row; i < lastRow; i++) 
        { 
            curr = mat[i][lastCol-1]; 
            mat[i][lastCol-1] = prev; 
            prev = curr; 
        } 
        lastCol--;   
        
        if (row < lastRow) 
        { 
            for (int i = lastCol-1; i >= col; i--) 
            { 
                curr = mat[lastRow-1][i]; 
                mat[lastRow-1][i] = prev; 
                prev = curr; 
            } 
        } 
        lastRow--; 
        
        if (col < lastCol) 
        { 
            for (int i = lastRow-1; i >= row; i--) 
            { 
                curr = mat[i][col]; 
                mat[i][col] = prev; 
                prev = curr; 
            } 
        } 
        col++; 
    } 
 
    

}
Q8
#include <bits/stdc++.h> 
/*

    intervals[i][0] = start point of i'th interval
    intervals[i][1] = finish point of i'th interval

*/

vector<vector<int>> mergeIntervals(vector<vector<int>> &arr)
{
    vector<vector<int>> ans;
     sort(arr.begin(), arr.end());

    for (int i = 0; i < arr.size(); i++) {
        
        if (ans.empty() || arr[i][0] > ans.back()[1]) {
            ans.push_back(arr[i]);
        }
        
        else {
            ans.back()[1] = max(ans.back()[1], arr[i][1]);
        }
    }
    return ans;
}
Q9
#include <bits/stdc++.h>

vector<int> ninjaAndSortedArrays(vector<int>& arr1, vector<int>& arr2, int m, int n) {
	// Write your code here.

	int left=m-1;
	int right=0;
	while(left>=0 && right<n)
	{
		if(arr2[right]<arr1[left])
		{
			swap(arr2[right],arr1[left]);
			right++;
			left--;
         } 
		else {
                  break;
                }
    }
	sort(arr1.begin(),arr1.begin()+m);
	sort(arr2.begin(),arr2.begin()+n);
	for(int i=m;i<m+n;i++)
	{
		arr1[i]=arr2[i-m];
	}
	return arr1;
}

Q10
#include <bits/stdc++.h>

int findDuplicate(vector<int> &arr, int n){
	// Write your code here.
	sort(arr.begin(),arr.end());
	for(int i=0;i<n-1;i++)
	{
		if(arr[i]==arr[i+1])
		{
			return (arr[i]);
		}
	}
}

Q11
#include <bits/stdc++.h>

pair<int,int> missingAndRepeating(vector<int> &arr, int n)
{ int hash[n+1]={0};

    

    for(int i=0;i<n;i++){

        hash[arr[i]]++;

    }

    int rep=-1,miss=-1;

    for(int i=1;i<=n;i++){

        if(hash[i]==2)

        rep=i;

        else if(hash[i]==0)

        miss=i;

 

        if(rep!=-1 && miss!=-1){

            break;

        }

    }

    return {miss,rep};

    
}
Q12
#include <bits/stdc++.h> 
long long getInversions(long long *arr, int n){
    // Write your code here.
    long long ans=0;
    for(int i=0;i<n;i++)
    {
        for(int j=i+1;j<n;j++)
        {
            if(arr[i]>arr[j])ans++;
        }
    }
    return ans;

}
Q13
bool searchMatrix(vector<vector<int>>& mat, int target) {
    int m=mat.size(),n=mat[0].size();
    for(int i=0;i<m;i++)
    {
        for(int j=0;j<n;j++)
        {
            if(mat[i][j]==target)return true;
            else if(mat[i][j]>target)return false;
        }
    }
    return false;
        
}
Q14
#include <bits/stdc++.h>

int modularExponentiation(int x, int n, int m) {
    long ans=1;

long xx=x;

while(n>0)

{

    if(n%2!=0)

    {

        ans=((ans)%m*(xx)%m)%m;

    }

    xx=((xx)%m*(xx)%m)%m;

    n=n>>1;

}

return (int)(ans%m);
	 
}
Q15
#include <bits/stdc++.h>

int findMajorityElement(int arr[], int n) {
	// Write your code here.
	int cnt=1,a=arr[0];
	for(int i=1;i<n;i++)
	{
        
		if(arr[i]==a)
		{
			cnt++;
		}
		else{
			            cnt--;
                        if (cnt == 0) {
                          a = arr[i];
                          cnt = 1;
                        }
                }





	}
	int b=0;
	for(int i=0;i<n;i++)
	{
		if(a==arr[i])
		{
			b++;
		}




	}
	if(b>n/2)return a;
	return -1;


}
Q16
#include <bits/stdc++.h>

vector<int> majorityElementII(vector<int> &arr)
{
    // Write your code here.
    unordered_map<int,int>mp;
    for(auto x:arr)mp[x]++;
    int k=arr.size()/3;
    vector<int>ans;
    for(auto x:mp)
    {
        if(x.second>k)
        {
            ans.push_back(x.first);
        }
    }
    return ans;
}
Q17
#include <bits/stdc++.h> 
int uniquePaths(int m, int n) {
	// Write your code here.
	  int path = 1;
    for (int i = n; i < (m + n - 1); i++) {
        path *= i;
        path /= (i - n + 1);
    }
    return path;
}
Q18
#include <bits/stdc++.h> 

#include <ext/pb_ds/assoc_container.hpp>

#include <ext/pb_ds/tree_policy.hpp>

using namespace __gnu_pbds;

  

#define ordered_set tree<int, null_type,less_equal<int>, rb_tree_tag,tree_order_statistics_node_update>
int reversePairs(vector<int> &arr, int n){
	// Write your code here.
		ordered_set os;

	os.insert(arr[n-1]);

	int ans = 0;

	for(int i = n-2; i >= 0; i--) {

		ans += os.order_of_key((arr[i]/2)+ arr[i]%2 );

		os.insert(arr[i]);

	}

	return ans;
}
Q19
#include <bits/stdc++.h>

vector<vector<int>> pairSum(vector<int> &arr, int s){
   // Write your code here.
   sort(arr.begin(),arr.end());
   vector<vector<int>> ans;
   for(int i=0;i<arr.size();i++)
   {
      for(int j=i+1;j<arr.size();j++)
      {
         if(arr[i]+arr[j]==s)
         {
            ans.push_back({arr[i],arr[j]});
         }
      }

   }
   return ans;

}
Q20
#include <bits/stdc++.h>

string fourSum(vector<int> nums, int target, int n) {
    // Write your code here.
      vector<vector<int>> ans;
         
        sort(nums.begin(),nums.end());
        for(int i=0;i<n;i++)
        {
            if(i>0 && nums[i]==nums[i-1])
                continue;
            for(int j=i+1;j<n;j++)
            {
                if(j>i+1 && nums[j]==nums[j-1])
                    continue;
                int k=j+1;
                int l=n-1;
                while(k<l)
                {
                    long long sum = nums[i];
                    sum += nums[j];
                    sum += nums[k];
                    sum += nums[l];
                    if(sum == target)
                    {
                        vector<int> temp={nums[i],nums[j],nums[k],nums[l]};
                        ans.push_back(temp);
                        k++;
                        l--;
                        while(k<l && nums[k]==nums[k-1]) k++;
                        while(k<l && nums[l]==nums[l+1]) l--;
                    }
                    else if (sum > target)
                        l--;
                    else
                        k++;
                    
                }
            }
        }
        if(ans.size()==0)
        return "No";
        else 
        return "Yes";
}
Q21
#include <bits/stdc++.h>

int lengthOfLongestConsecutiveSequence(vector<int> &arr, int n) {
    // Write your code here.
    sort(arr.begin(),arr.end());
    int count=1;
    int res=1;
    for(int i=1;i<n;i++)
    {
        if(arr[i]==arr[i-1] || arr[i]==arr[i-1]+1 )
        {
            if(arr[i]==arr[i-1]+1)count++;
            

        }
        else{
            count=1;
        }
        res=max(count,res);

    }
    
    return res;



}
Q22
#include <bits/stdc++.h>

int LongestSubsetWithZeroSum(vector < int > arr) {

  // Write your code here
  int ans=0;
  for(int i=0;i<arr.size();i++)
  {
    int cnt=0;
    
      for(int j=i;j<arr.size();j++)
      {
        cnt+=arr[j];
        if(cnt==0)ans=max(ans,j-i+1);

      }
    
  }
  return ans;

}
Q23
#include <bits/stdc++.h>

int subarraysXor(vector<int> &arr, int x)
{
    //    Write your code here.
    int xr=0;
    map<int,int>mp;
    mp[xr]++;
    int cnt=0;
    for(int i=0;i<arr.size();i++){
        xr=xr^arr[i];
        int y=xr^x;
        cnt+=mp[y];
        mp[xr]++;

    }
    return cnt;
}
Q24
#include <bits/stdc++.h> 
int uniqueSubstrings(string s)
{
    //Write your code here
    vector<int>mp(256,-1);
    int l=0,r=0,len=0;
    while(r<s.size()){
        if(mp[s[r]]!=-1){
            l=max(mp[s[r]]+1,l);
        }
        mp[s[r]]=r;
        len=max(len,r-l+1);
        r++;

    }
    return len;
}
Q25
#include <bits/stdc++.h>

/****************************************************************

    Following is the class structure of the LinkedListNode class:

    template <typename T>
    class LinkedListNode
    {
    public:
        T data;
        LinkedListNode<T> *next;
        LinkedListNode(T data)
        {
            this->data = data;
            this->next = NULL;
        }
    };

*****************************************************************/

LinkedListNode<int> *reverseLinkedList(LinkedListNode<int> *head) 
{
    // Write your code here
    if(head==NULL || head->next==NULL)return head;
    LinkedListNode<int> *prev=NULL; 
    LinkedListNode<int> *curr=head;
    LinkedListNode<int> *forward=head->next;
    while(curr!=NULL)
    {
        forward=curr->next;
        curr->next=prev;
        prev=curr;
        curr=forward;
        
        
        
    }  
    return prev; 
        

        

    
    
}


Q26
/*
Following is the class structure of the Node class:

class Node
{
public:
    int data;
    Node *next;
    Node()
    {
        this->data = 0;
        next = NULL;
    }
    Node(int data)
    {
        this->data = data; 
        this->next = NULL;
    }
    Node(int data, Node* next)
    {
        this->data = data;
        this->next = next;
    }
};
*/
int nodeLength(Node* head){
    int count=0;
    while(head!=NULL)
    {
        head=head->next;
        count++;
    }
    return count;
}


Node *reverse(Node *head) {
    // Write your code here
    int len=nodeLength(head);
    int ans=len/2;
    Node* temp=head;
    while(ans!=0)
    {
        temp=temp->next;
        ans--;
    }
    return temp;


}

Q27
#include <bits/stdc++.h>

/************************************************************

    Following is the linked list node structure.
    
    template <typename T>
    class Node {
        public:
        T data;
        Node* next;

        Node(T data) {
            next = NULL;
            this->data = data;
        }

        ~Node() {
            if (next != NULL) {
                delete next;
            }
        }
    };

************************************************************/

Node<int>* sortTwoLists(Node<int>* first, Node<int>* second)
{
    // Write your code here.
    if(first==NULL)return second;
    if(second==NULL)return first;
    Node<int>*l1=first,*l2=second,*temp,*res;
    if(l1->data>=l2->data)swap(l1,l2);
    res=l1;

    while(l1!=NULL && l2!=NULL)
    {
        temp=NULL;
        while(l1!=NULL && l1->data<=l2->data)
        {
            temp=l1;
            l1=l1->next;
        }
        temp->next=l2;
        swap(l1,l2);

    }
    

    return res;
    


    

}
Q 28

/*
Following is the class structure of the Node class:

class Node
{
public:
    int data;
    Node *next;
    Node()
    {
        this->data = 0;
        next = NULL;
    }
    Node(int data)
    {
        this->data = data; 
        this->next = NULL;
    }
    Node(int data, Node* next)
    {
        this->data = data;
        this->next = next;
    }
};
*/
int nodeLength(Node* head)
{
    int cnt=0;
    while(head!=NULL)
    {
        head=head->next;
        cnt++;
    }
    return cnt;
}

Node* removeKthNode(Node* head, int K)
{
    // Write your code here.
    int len=nodeLength(head);

    Node*t,* p=head;
    t=head;
    if(len-K==0)return p->next;
    
    
    while(len-K-1)
    {
        p=p->next;
        len--;
        
    }
   
   p->next=p->next->next;
//    delete(q);
    
    return t;
    

}

Q29
/**
 * Definition of linked list:
 *
 * class Node {
 * public:
 *      int data;
 *      Node *next;
 *      Node() {
 *          this->data = 0;
 *          this->next = NULL;
 *      }
 *      Node(int data) {
 *          this->data = data;
 *          this->next = NULL;
 *      }
 *      Node (int data, Node *next) {
 *          this->data = data;
 *          this->next = next;
 *      }
 * };
 *
 
 *************************************************************************/
 
 void insertAtTail(Node*  &head,Node* &tail,int digit)
 {
   Node* temp=new Node(digit);
   if(head==NULL)
   {
     head=temp;
     tail=temp;
     return;
    
   }
   else{
     tail->next=temp;
     tail=temp;
   }
   
 }
Node *addTwoNumbers(Node *num1, Node *num2)
{
    // Write your code here.
    
    
    
    Node* dummy=NULL,*temp=NULL;
    int carry=0;
    while(num1!=NULL || num2!=NULL || carry)
    {
      int sum=0;
      if(num1!= NULL)
      {
        sum+=num1->data;
        num1=num1->next;
        
      }
      if(num2!= NULL)
      {
        sum+=num2->data;
        num2=num2->next;
        
      }
      sum+=carry;
      carry=sum/10;
      sum%=10;
      
      insertAtTail(dummy,temp,sum);
      
      
        
      
      
      
    }
    
    return dummy;
}
Q30
#include <bits/stdc++.h>

/****************************************************************

    Following is the class structure of the LinkedListNode class:

    template <typename T>
    class LinkedListNode
    {
    public:
        T data;
        LinkedListNode<T> *next;
        LinkedListNode(T data)
        {
            this->data = data;
            this->next = NULL;
        }
    };

*****************************************************************/

void deleteNode(LinkedListNode<int> * node) {
    // Write your code here.
    if(node==NULL)return;
    if(node->next==NULL)
    {
        node=NULL;
        return;
    }
    node->data=node->next->data;
    LinkedListNode<int> *temp=node->next;
    node->next=temp->next;
    delete temp;

}
Q31
/****************************************************************

    Following is the class structure of the Node class:

        class Node
        {
        public:
            int data;
            Node *next;
            Node()
            {
                this->data = 0;
                next = NULL;
            }
            Node(int data)
            {
                this->data = data;
                this->next = NULL;
            }
            Node(int data, Node* next)
            {
                this->data = data;
                this->next = next;
            }
        };

*****************************************************************/

Node* findIntersection(Node *head1, Node *head2)
{
    //Write your code here
    if(head1==NULL || head2==NULL)return NULL;
    Node *d1=head1,*d2=head2;
    while(d1!=d2)
    {
        d1=(d1==NULL)?head2:d1->next;
        d2=(d2==NULL)?head1:d2->next;

    }
    
    

    return d1;
}
Q32
/****************************************************************

    Following is the class structure of the Node class:

        class Node
        {
        public:
            int data;
            Node *next;
            Node()
            {
                this->data = 0;
                next = NULL;
            }
            Node(int data)
            {
                this->data = data;
                this->next = NULL;
            }
            Node(int data, Node* next)
            {
                this->data = data;
                this->next = next;
            }
        };


*****************************************************************/

bool detectCycle(Node *head)
{
	//	Write your code here
    if(head == NULL ||  head->next==NULL)return false;
    Node* s=head,*f=head;
    while(f->next && f->next->next)
    {
        
        s=s->next;
        f=f->next->next;
        if(s==f)return true;

    }
    return false;
}
Q33
#include <bits/stdc++.h>

/****************************************************************

    Following is the class structure of the Node class:

        class Node
        {
        public:
	        int data;
	        Node *next;
	        Node(int data)
	        {
		        this->data = data;
		        this->next = NULL;
	        }
        };

*****************************************************************/
int calc(Node *head){
	Node*p=head;
	int l=0;
	while(p){
		l++;
		p=p->next;
	}
	return l;
}

Node *reverse(Node *head) {
  Node *p = head, *nxt, *prev = NULL;

  while (p) {
    nxt = p->next;
    p->next = prev;

    prev = p;
    p = nxt;
  }

  return prev;
}


Node *getListAfterReverseOperation(Node *head, int n, int b[]){
	// Write your code here.
	Node*dummy=new Node(0);

	dummy->next=head;
    Node*p=dummy,*curr,*nxt;
	if(head==NULL || head->next==NULL)return head;
	int len=calc(head);
	for(int i=0;i<n;i++){
		if(len==0)break;
		if(b[i]<=len){
			curr=p->next;
			nxt=curr->next;

			if(b[i]==0)continue;
			for(int j=0;j<b[i]-1;j++)
			{
				curr->next=nxt->next;
				nxt->next=p->next;
				p->next=nxt;
				nxt=curr->next;

			}
			len-=b[i];
			p=curr;


		}
		else if(len<=b[i])
		{
			p->next=reverse(p->next);
			len=0;
		}
	}



    return dummy->next;
	


}
Q34

#include <bits/stdc++.h> 
/****************************************************************

    Following is the class structure of the LinkedListNode class:

    template <typename T>
    class LinkedListNode
    {
    public:
        T data;
        LinkedListNode<T> *next;
        LinkedListNode(T data)
        {
            this->data = data;
            this->next = NULL;
        }
    };

*****************************************************************/
LinkedListNode<int>*reverse(LinkedListNode<int>*head)
{
    LinkedListNode<int>*curr=head,*forward=head,*newhead=NULL;
    while(curr!=NULL)
    {
        forward=curr->next;curr->next=newhead;
        newhead=curr;
        curr=forward;
        

        
    }
    return newhead;
}

bool isPalindrome(LinkedListNode<int> *head) {
    // Write your code here.
    if(head==NULL ||head->next==NULL )return true;
    LinkedListNode<int>* s=head,*f=head,*d=head;
    while(f->next && f->next->next)
    {
        s=s->next;
        f=f->next->next;
    }
    s->next=reverse(s->next);
    s=s->next;
    while(s!=NULL)
    {
        if(s->data!=d->data)return false;
        s=s->next;
        d=d->next;
    }
    return true;


}
Q 35

/****************************************************************

    Following is the class structure of the Node class:

        class Node
        {
        public:
            int data;
            Node *next;
            Node()
            {
                this->data = 0;
                next = NULL;
            }
            Node(int data)
            {
                this->data = data;
                this->next = NULL;
            }
            Node(int data, Node* next)
            {
                this->data = data;
                this->next = next;
            }
        };


*****************************************************************/

Node *firstNode(Node *head)
{
    //    Write your code here.
    if(head==NULL || head->next==NULL)return NULL;
    Node *s=head,*f=head,*entry=head;
    
    while(f->next && f->next->next)
    {
        s=s->next;
        f=f->next->next;
        
        if(s==f){
            if(s==entry)return s;
            while(true)
            {
                s=s->next;
                entry=entry->next;
                if(s==entry)return entry;
                
            }

        }
     }
     return NULL;

}
Q36
/*
 * Definition for linked list.
 * class Node {
 *  public:
 *		int data;
 *		Node *next;
 * 		Node *child;
 *		Node() : data(0), next(nullptr), child(nullptr){};
 *		Node(int x) : data(x), next(nullptr), child(nullptr) {}
 *		Node(int x, Node *next, Node *child) : data(x), next(next), child(child) {}
 * };
 */

Node* mergeTwoLists(Node* a, Node* b) {

    

    Node *temp = new Node(0);

    Node *res = temp; 

    

    while(a != NULL && b != NULL) {

        if(a->data < b->data) {

            temp->child = a; 

            temp = temp->child; 

            a = a->child; 

        }

        else {

            temp->child = b;

            temp = temp->child; 

            b = b->child; 

        }

    }

    

    if(a) temp->child = a; 

    else temp->child = b; 

    

    return res -> child; 

    

}

Node* flattenLinkedList(Node* head) 

{

    if(head == NULL || head->next == NULL) return head;

 

    Node* L2 = flattenLinkedList(head->next);

    head->next = NULL;

    Node* nhead = mergeTwoLists(head, L2);

    return nhead;

}

 

Q37
/**
 * Definition for singly-linked list.
 * class Node {
 * public:
 *     int data;
 *     Node *next;
 *     Node() : data(0), next(nullptr) {}
 *     Node(int x) : data(x), next(nullptr) {}
 *     Node(int x, Node *next) : data(x), next(next) {}
 * };
 */
 

Node *rotate(Node *head, int k) {
     // Write your code here.
     if(head==NULL || head->next==NULL || k==0)return head;
     Node*q=head;
     int len=1;
     while(q->next && ++len)
     {   
          q=q->next;
     }
     q->next=head;
     k=k % len;
     k=len-k;
     while(k--)
     {
          q=q->next;
     }
     head=q->next;
     q->next=NULL;
     return head;
}
Q38
#include <bits/stdc++.h>

/*************************************************************

    Following is the LinkedListNode class structure

    template <typename T>   
    class LinkedListNode
    {
        public:
        T data;
        LinkedListNode<T> *next;
        LinkedListNode<T> *random;
        LinkedListNode(T data)
        {
            this->data = data;
            this->next = NULL;
        }
    };

*************************************************************/
void insertAtTail(LinkedListNode<int> *&head, LinkedListNode<int> *&tail, int value)

{

    LinkedListNode<int> *newNode=new LinkedListNode<int>(value);

    if(head==NULL)

    {

        head=newNode;

        tail=newNode;

    }

    else{

        tail->next=newNode;

        tail=newNode;

    }

}

LinkedListNode<int> *cloneRandomList(LinkedListNode<int> *head)

{

    if(head==NULL)

    {

        return head;

    }

    LinkedListNode<int> *cloneHead=NULL;

    LinkedListNode<int> *cloneTail=NULL;

    LinkedListNode<int> *temp=head;

    while(temp)

    {

        insertAtTail(cloneHead, cloneTail, temp->data);

        temp=temp->next;

    }

    LinkedListNode<int> *originalNode=head;

    LinkedListNode<int> *cloneNode=cloneHead;

    while(originalNode && cloneNode)

    {

        LinkedListNode<int> *forward1=originalNode->next;

        originalNode->next=cloneNode;

        originalNode=forward1;

        LinkedListNode<int> *forward2=cloneNode->next;

        cloneNode->next=originalNode;

        cloneNode=forward2;

    }

    temp=head;

    cloneNode=cloneHead;

    while(temp)

    {

        if(temp->next!=NULL)

        {

            if(temp->random!=NULL)

            {   

                temp->next->random=temp->random->next;

            }

            else

            {

                temp->next->random=temp->random;

            }

            temp=temp->next->next;

        }

    }

    originalNode=head;

    cloneNode=cloneHead;

    while(originalNode && cloneNode)

    {

        originalNode->next=cloneNode->next;

        originalNode=originalNode->next;

        if(originalNode!=NULL)

        {

            cloneNode->next=originalNode->next;

            cloneNode=cloneNode->next;

        }

    }

    return cloneHead;

}
Q39
#include <bits/stdc++.h> 
vector<vector<int>> findTriplets(vector<int>nums, int n, int K) {
	// Write your code here.
	if(n<3)return {};

	vector<vector<int>> triplets;

    sort(nums.begin(), nums.end());

	for(int i = 0; i<n-2; i++){
        int start = i+1;
        int end = n-1;
        while(start<end){
                
            int sum = nums[i] + nums[start] + nums[end];
            if(sum == K){
                triplets.push_back({nums[i], nums[start], nums[end]});
                start++;
                end--;
                while(start<n && nums[start] == nums[start-1]){
					start++;
				}
					
                while(end>i && nums[end] == nums[end+1]){
					end--;
				}	
            }
			else if(sum>K){
                end--;
            } 
			else {
              start++;
            }
        }
        while (i < n - 1 && nums[i] == nums[i + 1])
          i++;
    }
    return triplets;
}
Q40
#include<bits/stdc++.h>
#include<algorithm>
long long getTrappedWater(long long* arr, int n) {
    // Write your code here.
    if(n==1)return 0;
    vector<long long>left(n,-1);
    vector<long long>right(n,-1);
    
    left[0]=arr[0];
    right[n-1]=arr[n-1];
    for(int i=1;i<n;i++){
        left[i]=max(left[i-1],arr[i]);

    }
    for(int i=n-2;i>=0;i--){
        right[i]=max(right[i+1],arr[i]);
    }

    long ans=0;
    for(int i=0;i<n;i++){
        ans+=min(left[i],right[i])-arr[i];
    }
    return ans;

}
Q41
#include<bits/stdc++.h>
int removeDuplicates(vector<int> &arr, int n) {
	// Write your code here.
    
	int i=1;
	for(int j=1;j<n;j++)
	{
		if(arr[j]!=arr[j-1])
		{
			i++;
		}

	}
	return i;
}
Q42
int longestSubSeg(vector<int> &arr , int n, int k){
    // Write your code here.
    int flip=0;
    int ans=0;
    int i=0;
    int j=0;
    while(j<n)
    {
        if(arr[j]==0){
            flip++;
            
        }
        while(flip>k){
            if(arr[i]==0)
            {
                flip--;
            }
            i++;
        }
        ans=max(ans,j-i+1);
        j++;
        

    }
    return ans;
}
Q43
#include <bits/stdc++.h>
struct meeting{
    int start;
    int end;
    int pos;
};
bool comparator(struct meeting m1,meeting m2){
    if(m1.end<m2.end)return true;
    else if(m1.end>m2.end)return false;
    else if(m1.pos<m2.pos)return true;
    return false;
}




vector<int> maximumMeetings(vector<int> &star, vector<int> &en) {
    // Write your code here.
    int n=star.size();


    struct meeting meet[n];
    for(int i=0;i<n;i++){
        meet[i].start=star[i];
        meet[i].end=en[i];
        meet[i].pos=i+1;
    }
    sort(meet,meet+n,comparator);
    int limit=meet[0].end;
    vector<int>ans;
    ans.push_back(meet[0].pos);
    for(int i=1;i<n;i++)
    {
        if(limit<meet[i].start)
        {
            limit=meet[i].end;
            ans.push_back(meet[i].pos);

        }
    }
    return ans;
}
Q44

int deleteElement(int arr[], int n, int x)
{

int i;
for (i=0; i<n; i++)
    if (arr[i] == x)
        break;
if (i < n)
{
    n = n - 1;
    for (int j=i; j<n; j++)
        arr[j] = arr[j+1];
}
return n;
}
int calculateMinPatforms(int at[], int dt[], int n) {
    for(int i=0;i<n;i++)
    {
        if(dt[i]<at[i]){
            n=deleteElement(at,n,at[i]);
            n=deleteElement(dt,n,dt[i]);
        }
    }
    // Write your code here.
    int plat=0,free=0,full=0,j=0;

    sort(at,at+n);
    sort(dt,dt+n);

    for(int i=0;i<n;i++){
            if(plat==full){
                plat++;
                full++;

            }
            else{
              if (free > 0) {
                free--;
                full++;
              }
              
            }        
        if(dt[j]<at[i+1]){
            j++;
            free++;
            full--;
        }
    }
    return plat;

}
Q45
#include <bits/stdc++.h> 
bool comparator(vector<int>j1,vector<int>j2) {
    return j1[1]>j2[1] || (j1[1]==j2[1] && j1[0]>=j2[0]);
}
int jobScheduling(vector<vector<int>> &jobs)
{
    // Write your code here
    int n=jobs.size();
    sort(jobs.begin(),jobs.end(),comparator);
    int maxdeadline=-1,profit=0;
    for(int i=0;i<n;i++){
        maxdeadline=max(maxdeadline,jobs[i][0]);
    }
    vector<int>ans(maxdeadline+1,-1);
    for(int i=0;i<n;i++){
        int dummy=jobs[i][0];
        for(int j=dummy;j>0;j--){
            if(ans[j]==-1){
                ans[j]=jobs[i][1];
                profit+=jobs[i][1];
                

                break;
            }
        }
    }

    return profit;
}
Q46
#include <bits/stdc++.h> 
bool comparator(pair<int,int> a,pair<int,int>b)
{
    double r1=(double)a.second/(double)a.first;
    double r2=(double)b.second/(double)b.first;
    return r1>r2;
}
double maximumValue (vector<pair<int, int>>& items, int n, int w)
{
    // Write your code here.
    // ITEMS contains {weight, value} pairs.

  
    sort(items.begin(),items.end(),comparator);
    double count=0;int j=0;
    while(w && j<n){
        if(w>=items[j].first){
            count+=items[j].second;
            w-=items[j].first;

        }
        else{
            count+=(double)(w)*items[j].second/items[j].first;
            break;
        }
        j++;
        



    }
    return count;







}
Q47
#include <bits/stdc++.h> 
int findMinimumCoins(int amount) 
{
    // Write your code here
    int arr[9]={1,2,5,10,20,50,100,500,1000};
    int coins=0;
    for(int i=8;i>=0;i--){
        coins+=amount/arr[i];
        amount=amount%arr[i];
    }
    return coins;
}
Q48
#include <bits/stdc++.h>

struct Interval {
    int start, end;
};
  

bool compareInterval(Interval i1, Interval i2)
{
    return(i1.end<i2.end);
}
int maximumActivities(vector<int> &star, vector<int> &en) {
    // Write your code here.
    int n=star.size();
    struct Interval ans[n];
    for(int i=0;i<n;i++){
        ans[i].start=star[i];
        ans[i].end=en[i];
    }
    sort(ans,ans+n,compareInterval);
    int count=1,limit=ans[0].end;

    for(int i=1;i<n;i++)
    {
        if(limit<=ans[i].start)
        {
            count++;
            limit=ans[i].end;
        }



    }
    return count;

}
Q49
#include <bits/stdc++.h> 
void recursion(vector<int>& num,vector<int> &ans,int sum,int i,int n)
{
    if(i==n){
        ans.push_back(sum);
        return;
    }
    recursion(num,ans,sum+num[i],i+1,n);
    recursion(num,ans,sum,i+1,n);
    
}
vector<int> subsetSum(vector<int> &num)
{
    // Write your code here.
    int n=num.size();
    
    vector<int>ans;
    
    recursion(num,ans,0,0,n);
    sort(ans.begin(),ans.end());
    
   
    return ans;


}
Q50
#include <bits/stdc++.h> 
void recursion(vector<vector<int>> &ans,vector<int> &dp,vector<int> &arr,int ind){
    ans.push_back(dp);
    for(int i=ind;i<arr.size();i++)
    {
        if(i!=ind && arr[i]==arr[i-1])
        {
            continue;
            }
        dp.push_back(arr[i]);
        recursion(ans,dp,arr,i+1);
        dp.pop_back();
    }
}

vector<vector<int>> uniqueSubsets(int n, vector<int> &arr)
{
    // Write your code here.
    sort(arr.begin(),arr.end());
   vector<vector<int>>ans;
   vector<int>dp;
   recursion(ans,dp,arr,0);
   return ans;
}
Q51
void recursion(vector<int> &arr,vector<vector<int>>&ans,vector<int>dp,int ind,int k,int n)
{
    int sum=0;
    for(int i=0;i<dp.size();i++)
    {
        sum+=dp[i];

    }
    if(sum==k)ans.push_back(dp);
    for(int i=ind;i<n;i++)
    {
       
        dp.push_back(arr[i]);
        recursion(arr,ans,dp,i+1,k,n);
        dp.pop_back();
    }
}
vector<vector<int>> findSubsetsThatSumToK(vector<int> arr, int n, int k)
{
    // Write your code here.
    
    vector<vector<int>>ans;
    vector<int>dp;
    recursion(arr,ans,dp,0,k,n);
    return ans;

}
Q52
#include<algorithm>
void findCombs(int index , int target , vector<int> &arr, vector<int> &ds, vector<vector<int>> &res){

	//BASE CASE
	if(target == 0){
		res.push_back(ds);							
		return;  					
	}

        for (int i = index; i < arr.size(); i++) {
		// CONDITION TO AVOID DUPLICATE ENTRIES AND COMBINATIONS
          if (i > index and arr[i] == arr[i - 1]) {
            continue; 
          }
		// OPTIMISING BY BREAKING LOOP AND INITIALISING A NEW ELEMENT  AS A STARTING POINT
          if (arr[i] > target) {
            break;
          }
          ds.push_back(arr[i]);

          findCombs(i + 1, target-arr[i], arr, ds, res);
		  /* THE ELEMENT IS REMOVED SO THAT A NEW COMBINATION CAN BE GENERATED
		   WHEN RECURSION CALL IS BACK-TRACKED */
		  ds.pop_back(); 
        }
}
vector<vector<int>> combinationSum2(vector<int> &arr, int n, int target)
{
	// Write your code here.

	sort(arr.begin(),arr.end());
	vector<int> ds;
	vector<vector<int>> res;
	findCombs(0, target, arr, ds, res);
	
	return res;
}
Q53
#include <bits/stdc++.h> 
bool isPalindrome(int start,int end,string&s){
    while(start<=end){
        if(s[start++]!=s[end--]){
          return false;}
    }
    return true;
}
void recursion(string &s,vector<vector<string>>&ans,vector<string>&dp,int ind){
    if(ind==s.length()){
        
        ans.push_back(dp);
        return;
    }
    for(int i=ind;i<s.length();++i)
    {
        if(isPalindrome(ind,i,s)){
            dp.push_back(s.substr(ind,i-ind+1));
            recursion(s,ans,dp,i+1);
            dp.pop_back();



        }
    }
}

vector<vector<string>> partition(string &s) 
{
    // Write your code here.
    vector<vector<string>>ans;
    vector<string>dp;
    recursion(s,ans,dp,0);


    return ans;


}
Q54
string kthPermutation(int n, int k) {
    int fact = 1;
      vector < int > numbers;
      for (int i = 1; i < n; i++) {
        fact = fact * i;
        numbers.push_back(i);
      }
      numbers.push_back(n);
      string ans = "";
      k = k - 1;
      while (true) {
        ans = ans + to_string(numbers[k / fact]);
        numbers.erase(numbers.begin() + k / fact);
        if (numbers.size() == 0) {
          break;
        }

        k = k % fact;
        fact = fact / numbers.size();
      }
      return ans;
   
  
}
Q55
string kthPermutation(int n, int k) {
    int fact = 1;
      vector < int > numbers;
      for (int i = 1; i < n; i++) {
        fact = fact * i;
        numbers.push_back(i);
      }
      numbers.push_back(n);
      string ans = "";
      k = k - 1;
      while (true) {
        ans = ans + to_string(numbers[k / fact]);
        numbers.erase(numbers.begin() + k / fact);
        if (numbers.size() == 0) {
          break;
        }

        k = k % fact;
        fact = fact / numbers.size();
      }
      return ans;
   
  
}
Q56
#include <bits/stdc++.h>
using namespace std;

void solve(int col, int n, vector<vector<int>> &res, vector<vector<int>> &mat,
           vector<int> &leftRow, vector<int> &lowerDiagonal,
           vector<int> &upperDiagonal) {
  if (col == n) {
    vector<int> ans;
    for (auto i : mat)
      for (auto j : i)
        ans.push_back(j);

    res.push_back(ans);
    return;
  }

  for (int i = 0; i < n; i++) {
    if (leftRow[i] == 0 and lowerDiagonal[i + col] == 0 and
        upperDiagonal[(n - 1) + (col - i)] == 0) {
      leftRow[i] = 1;
      lowerDiagonal[i + col] = 1;
      upperDiagonal[(n - 1) + (col - i)] = 1;
      mat[i][col] = 1;

      solve(col + 1, n, res, mat, leftRow, lowerDiagonal, upperDiagonal);

      leftRow[i] = 0;
      lowerDiagonal[i + col] = 0;
      upperDiagonal[(n - 1) + (col - i)] = 0;
      mat[i][col] = 0;
    }
  }
}

vector<vector<int>> solveNQueens(int n) {
  vector<vector<int>> res;
  vector<vector<int>> mat(n, vector<int>(n));

  vector<int> leftRow(n), lowerDiagonal(2 * n - 1), upperDiagonal(2 * n - 1);

  solve(0, n, res, mat, leftRow, lowerDiagonal, upperDiagonal);
  return res;
}
Q57
bool valid(int i,int j,int k,int matrix[9][9]){
    for(int m=0;m<9;m++){
        if(matrix[m][j]==k)return false;
        else if(matrix[i][m]==k)return false;
        else if(matrix[3*(i/3)+m/3][3*(j/3)+m%3]==k)return false;
    }
    return true;

}
bool solve(int matrix[9][9]){
    for(int i=0;i<9;i++)
    {
        for(int j=0;j<9;j++)
        {
            if(matrix[i][j]==0){
                for(int k=1;k<=9;k++){
                   if(valid(i,j,k,matrix))
                   {matrix[i][j]=k;
                    if(solve(matrix))return true;
                    else matrix[i][j]=0;
                    
                    }
                }
                return false;
            }
            

        }
    }
    return true;
}
bool isItSudoku(int matrix[9][9]) {

    // Write your code here.
    solve(matrix);
   
}
Q58
#include <bits/stdc++.h>

bool isSafe(int node, int v, int color, vector<int> &colorOfNode, vector<vector<int>> &mat){
    for(int i = 0; i < v; i++){
        if(mat[node][i] == 1){
            if(colorOfNode[i] == color){
                return false;
            }
        }
    }

    colorOfNode[node] = color;
    return true;
}

bool solve(int node, int v, int m, vector<int> &colorOfNode, vector<vector<int>> &mat){
    if(node == v){
        return true;
    }
    
    for(int i = 1; i <= m; i++){
        if(isSafe(node, v, i, colorOfNode, mat)){
            if(solve(node+1, v, m, colorOfNode, mat)){
                return true;
            }
            colorOfNode[node] = 0;
        }
    }

    return false;
}

string graphColoring(vector<vector<int>> &mat, int m) {
    int v = mat.size();
    vector<int> colorOfNode(v, 0);

    if(solve(0, v, m, colorOfNode, mat)){
        return "YES";
    }
    return "NO";
}
Q59
#include <bits/stdc++.h> 
void recursion(vector<vector<int>>&maze,int n,vector<vector<int>>&ans,int row,int col,vector<vector<int>>&vis){

  
  
    if (row == n-1 && col == n-1 ) {
      vector<int>temp;
      vis[row][col]=1;
      for(int i=0;i<n;i++)
      {
        for(int j=0;j<n;j++)
        {
          temp.push_back(vis[i][j]);
        }
      }
      vis[row][col]=0;
      ans.push_back(temp);

      
      return;
    }

    if (row-1>=0 && maze[row - 1][col] == 1 && !vis[row - 1][col]) {
      
      vis[row - 1][col] = 1;
      recursion(maze, n, ans, row - 1, col, vis);
      vis[row - 1][col] = 0;
      
    }
    if (col-1>=0 &&maze[row][col - 1] == 1 && !vis[row][col - 1]) {
      
      vis[row][col - 1] = 1;
      recursion(maze, n, ans,  row, col - 1, vis);
      vis[row][col - 1] = 0;
      
    }
    if (col+1<n&&maze[row][col + 1] == 1 && !vis[row][col + 1]) {
      
      vis[row][col + 1] = 1;
      recursion(maze, n, ans, row, col + 1, vis);
      vis[row][col + 1] = 0;
      
    }

    if (row+1<n&&maze[row + 1][col] == 1 && !vis[row + 1][col]) {
      
      vis[row + 1][col] = 1;
      recursion(maze, n, ans,  row + 1, col, vis);
      vis[row + 1][col] = 0;
      
    }
}


vector<vector<int> > ratInAMaze(vector<vector<int> > &maze, int n){
  // Write your code here.
   vector < vector < int >> vis(n, vector < int > (n, 0));
  vector<vector<int>>ans;
  
  if(maze[0][0])vis[0][0]=1;recursion(maze,n,ans,0,0,vis);
  return ans;


}
Q60
#include <bits/stdc++.h> 

 

void f(int idx,string t,string &s,unordered_map<string,int> &mp,vector<string> &ans)

{

    if(idx==s.length())

    {

        ans.push_back(t);

        return;

    }

 

    string a;

    for(int i=idx;i<s.length();i++)

    {

        a+=s[i];

        if(mp.find(a)!=mp.end())

        {

            if(t.length()==0)

              f(i+1,t+a,s,mp,ans);

            else

              f(i+1,t+" "+a,s,mp,ans);

        }

    }

}

 

vector<string> wordBreak(string &s, vector<string> &words)

{

    // Write your code here

    unordered_map<string,int> mp;

    for(auto it:words)

      mp[it]++;

    

    vector<string> ans;

    string t;

    f(0,t,s,mp,ans);

    return ans;

 

}
Q61
int NthRoot(int n, int m) {
  // Write your code here.
  int low=1;
  int high=m;
  
  while(high-low >=0)
  {
    int mid=(low+high)/2;
    if(pow(mid,n)==m)return mid;
    else if(pow(mid,n)<m){
      low=mid+1;
    }
    else{
      high=mid-1;
    }
  }
  return -1;
  

  
}
Q62
#include<bits/stdc++.h>
int countsmallerThanMid(vector<int>&row,int mid){
    int l=0,h=row.size()-1;
    while(l<=h){
        int md=(l+h)>>1;
        if(row[md]<=mid){
            l=md+1;
        }
        else {
            h=md-1;
        }
    }
    return l;
}
int getMedian(vector<vector<int>> &matrix)
{
    // Write your code here.
    int low=1;
    int high=1e9;
    int n=matrix.size();
    int m=matrix[0].size();
    while(low<=high){
        int mid=(low+high)>>1;
        int cnt=0;
        for(int i=0;i<n;i++){
            cnt+=countsmallerThanMid(matrix[i],mid);
        }
        if(cnt<=(n*m)/2){
            low=mid+1;
        }
        else{
            high=mid-1;
        }

    }
    return low;
    }
Q63
int singleNonDuplicate(vector<int>& arr)
{
	// Write your code here

	int low  = 0, high = arr.size() - 1;

    // Edge case - Only one element

    if(high == 0)

        return arr[0];

 

    // Edge case - Ans is first or last element

    if(arr[0]!=arr[1])

        return arr[0];

    else if(arr[high] != arr[high-1])

        return arr[high];  

    while(low <= high){

        int mid = low + (high-low)/2;

 

        // If mid is the single element

        if(arr[mid] != arr[mid-1] && arr[mid] != arr[mid+1])

            return arr[mid];

        // If mid is odd, the single element lies on the other side

        if(mid % 2 == 1){

            if(arr[mid] == arr[mid-1])

                low = mid+1;

            else

                high = mid-1;

        }  

 // If mid is even, the single element lies on the same side

        else{

            if(arr[mid] == arr[mid-1])

                high = mid-2;

            else

                low = mid+2;

        }

    }        


}
Q64
int search(int* arr, int n, int key) {
    // Write your code here.
    int low=0,high=n-1;
    while(low<=high){
        int mid=(low+high)>>1;
        if(arr[mid]==key)return mid;
        if(arr[low]<=arr[mid]){
            if(arr[low]<=key and arr[mid]>key){
                high=mid-1;
            }
            else{
                low=mid+1;
            }
        }
        else{
            if(key>arr[mid] and arr[high]>=key){
                low=mid+1;
            }
            else{
                high=mid-1;
            }
        }
    }
    return -1;
}
Q65
#include<bits/stdc++.h>
double median(vector<int>& a, vector<int>& b) {
	// Write your code here.
        if (a.size() > b.size()) {
          median(b, a);
        }
        int n1=a.size(),n2=b.size();
	int low=0;
	int high=n1;
	while(low<=high){
		int cut1=low+(high-low)/2;
		int cut2=(n1+n2+1)/2-cut1;
		int left1=(cut1==0)?INT_MIN:a[cut1-1];
		int left2=(cut2==0)?INT_MIN:b[cut2-1];
		int right1=(cut1==n1)?INT_MAX:a[cut1];
		int right2=(cut2==n2)?INT_MAX:b[cut2];
        if(left1<=right2 && left2<=right1){
			if((n1+n2)%2==0){
				return ((max(left1,left2))+(min(right1,right2)))/2.0;
			}
			else{
				return max(left1,left2);
			}
		}
		else if(left1>right2){
			high=cut1-1;

		}
		else{
			low=cut1+1;
		}

	}
	
}
Q66
//bruteforce int ninjaAndLadoos(vector<int> &row1, vector<int> &row2, int m, int n, int k) {
//     // Write your code here.
//     int i=0,j=0,ans=0;
    
//     while(k){
//         if(i<n and j<n){
//           if (row1[i] < row2[j]) {
//             ans = row1[i];
//             i++;
//           }
//           else {
//              ans = row2[j];
//              j++;
//          }
//         } 
//         else if(i<n){
//           ans = row1[i];
//           i++;
//         }
//         else{
//             ans=row2[j];
//             j++;

//         }
//         k--;

//     }
//     return ans;
// }
#include<bits/stdc++.h>
int ninjaAndLadoos(vector<int> &a, vector<int> &b, int m, int n, int k){
    if(m>n) ninjaAndLadoos(b,a,n,m,k);
    int low=max(0,k-n),high=min(k,m);
    while(low<=high){
        int cut1=(low+high)>>1;
        int cut2=k-cut1;
        
		int left1=(cut1==0)?INT_MIN:a[cut1-1];
		int left2=(cut2==0)?INT_MIN:b[cut2-1];
		int right1=(cut1==m)?INT_MAX:a[cut1];
		int right2=(cut2==n)?INT_MAX:b[cut2];
        if(left1<=right2 and left2<=right1){
            return max(left1,left2);
        }
        else if(left1>right2){
            high=cut1-1;
        }
        else{
            low=cut1+1;
        }
    }

}
Q67
#include <bits/stdc++.h> 

 

bool valid(int n, int m,vector<int> time,long long a)

{

    int cnt=0;

    long long sum=0;

    for(int i=0;i<m;i++)

    {

        if(sum+time[i]<=a)

          sum+=time[i];

        else

        {

            cnt++;

            sum=time[i];

        }

    }

 

    return  cnt<n;

 

}

 

long long ayushGivesNinjatest(int n, int m, vector<int> time) 

{   

    // Write your code here.

    long long sum=0;

    int maxi=0;

    for(auto it:time)

    {

        sum+=it;

        maxi=max(maxi,it);

    }

 

    long long ans=0;

    long long low=maxi,high=sum;

    while(low<=high)

    {

        long long mid=(low+high)/2;

        if(valid(n,m,time,mid))

        {

            ans=mid;

            high=mid-1;

        }

        else

          low=mid+1;

    }

    return ans;

}
Q68
#include <bits/stdc++.h>
bool canAssign(int c, int mid, vector<int> &positions) {
  int allot = 1, player = positions[0];
  for (int i = 1; i < positions.size(); i++) {
    if (positions[i] - player >= mid) {
      allot++;
      player = positions[i];
    }

    if (allot == c)
      return true;
  }

  return false;
}

int chessTournament(vector<int> &positions, int n, int c) {
  sort(positions.begin(), positions.end());
  int low = 1, high = positions[n - 1] - positions[0];
  int ans = -1;

  while (low <= high) {
    int mid = low + (high - low) / 2;
    if (canAssign(c, mid, positions)) { // minimum distance
      ans = mid;
      low = mid + 1;
    } else
      high = mid - 1;
  }
  return ans;
}
Q69
#include <bits/stdc++.h>
#include<queue>

vector<int> minHeap(int n, vector<vector<int>>& q) {
    // Write your code here.
    vector<int>ans;
    priority_queue<int,vector<int>,greater<int>>pq;
    for(int i=0;i<n;i++){
        if(q[i][0]==0){
            pq.push(q[i][1]);
        }
        else{
            ans.push_back(pq.top());
            pq.pop();
            
            
        }

    }
    return ans;
}

Q70
// #include<queue>
// vector<int> kthSmallLarge(vector<int> &arr, int n, int k)
// {
// 	// Write your code here.
// 	vector<int>ans;
	
// 	priority_queue<int>pmax;
// 	priority_queue<int,vector<int>,greater<int>>pmin;
//         for (int i = 0; i < n; i++) {
//           pmax.push(arr[i]);
// 		  pmin.push(arr[i]);
//         }
//         int i=k-1,j=i;
// 	while(i>0)
// 	{
// 		pmin.pop();
// 		i--;
	
		
// 	}
// 	ans.push_back(pmin.top());
// 	while(j>0){
// 		pmax.pop();
// 		j--;
// 	}
// 	ans.push_back(pmax.top());
	
// 	return ans;
// }
#include<math.h>

#include<bits/stdc++.h>

#include<iostream>

vector<int> kthSmallLarge(vector<int> &arr, int n, int k)

{

    // Write your code here.

    sort(arr.begin(),arr.end());

    return {arr[k-1],arr[n-k]};

}
Q71
#include <bits/stdc++.h> 
vector<int> kMaxSumCombination(vector<int> &a, vector<int> &b, int n, int k){
	// Write your code here.
	priority_queue<int>pq;
	for(int i=0;i<n;i++){
		for(int j=0;j<n;j++){
			pq.push(a[i]+b[j]);

		}
	}
	vector<int>ans;
	while(k--){
		ans.push_back(pq.top());
		pq.pop();

	}
	return ans;

}
Q72
#include<queue>
#include<bits/stdc++.h>
void findMedian(int *arr, int n)
{
    // Write your code here
    priority_queue<int>pmax;
    priority_queue<int,vector<int>,greater<int>>pmin;
    for(int i=0;i<n;i++){
        if(pmax.empty() or pmax.top()>=arr[i]){
            pmax.push(arr[i]);
        }
        else{
            pmin.push(arr[i]);
        }
        if(pmax.size()>pmin.size()+1)
        {
            pmin.push(pmax.top());
            pmax.pop();
        }
        else if(pmin.size()>pmax.size())
        {
            pmax.push(pmin.top());
            pmin.pop();
        }
        
         
        
        if(pmax.size()>pmin.size()){
                cout<<pmax.top()<<" ";
            }
        else{
                cout<<(pmin.top()+pmax.top())/2<<" ";
            }   
        
    }
    
}
Q73
#include <bits/stdc++.h>
#include<queue> 
vector<int> mergeKSortedArrays(vector<vector<int>>&kArrays, int k)
{
    // Write your code here.
     vector<int>ans;
    priority_queue<int,vector<int>,greater<int>>pq; 
    
   for(auto i:kArrays){
       for(auto j:i){
           pq.push(j);
       }
   }
   


    while(!pq.empty()){
        ans.push_back(pq.top());
        pq.pop();

    }
    return ans;

    
}

Q74
#include <bits/stdc++.h> 
vector<int> KMostFrequent(int n, int k, vector<int> &arr)
{
    // Write your code here.
   vector<int>ans;
   map<int,int>mp;
   for(int i=0;i<n;i++){
       mp[arr[i]]++;
          }
    priority_queue<pair<int,int>>q;
    for(auto i:mp){
        q.push({i.second,i.first});
    }
    for(int i=0;i<k;i++){
        ans.push_back(q.top().second);
        q.pop();
    }
    sort(ans.begin(),ans.end());
    return ans;
}
Q75
/*
    Your Trie object will be instantiated and called as such:
    Trie* obj = new Trie();
    obj->insert(word);
    bool check2 = obj->search(word);
    bool check3 = obj->startsWith(prefix);
 */
struct Node{
    Node *links[26];
    bool flag=false;
    bool containskey(char ch){
        return links[ch-'a']!=NULL;
    }
    void put(char ch,Node* node){
        links[ch-'a']=node;

    }
    Node* get(char ch){
        return links[ch-'a'];
    }
    bool setEnd(){
        flag=true;
    }
    bool isEnd()
    {
        return flag;
    }
};

class Trie {
    private: Node* root;

public:

    /** Initialize your data structure here. */
    Trie() {

        root=new Node();

    }

    /** Inserts a word into the trie. */
    void insert(string word) {
        Node* node=root;
        for(int i=0;i<word.size();i++)
        {
            if(!node->containskey(word[i]))
            {
                node->put(word[i],new Node());

            }
            node=node->get(word[i]);

        }
        node->setEnd();


    }

    /** Returns if the word is in the trie. */
    bool search(string word) {
        Node *node=root;
        for(int i=0;i<word.size();i++)
        {
            if(!node->containskey(word[i])){
                return false;

            }
            node=node->get(word[i]);
        }
        return node->isEnd();

    }

    /** Returns if there is any word in the trie that starts with the given prefix. */
    bool startsWith(string prefix) {
        Node*node=root;
        for(int i=0;i<prefix.size();i++)
        {
             if(!node->containskey(prefix[i])){
                return false;

            }
            node=node->get(prefix[i]);

        }
        return true;

    }
};
Q76


