
Q1
#include <bits/stdc++.h>

void setZeros(vector<vector<int>> &matrix)
{
	int col0=1;
	int m=matrix.size();
	int n=matrix[0].size();
	for(int i=0;i<m;i++)
	{
		for(int j=0;j<n;j++)
		{
			if(matrix[i][j]==0)
			{
				matrix[i][0]=0;
				if(j!=0)
				{
					matrix[0][j]=0;
				}
				else col0=0;
			}
		}
	}
	for(int i=1;i<m;i++)
	{
		for(int j=1;j<n;j++)
		{
            if (matrix[i][j] != 0) {
                if (matrix[i][0] == 0 || matrix[0][j] == 0)
                      matrix[i][j] = 0;
            }
        }
	}
	if(matrix[0][0]==0){
		for(int i=1;i<n;i++)
		{
			matrix[0][i]=0;
		}
	}
	if(col0==0){
		for(int i=0;i<m;i++)
		{
			matrix[i][0]=0;
		}
	}
	
	

}

Q2

#include <bits/stdc++.h>

vector<vector<long long int>> printPascal(int n) 
{
   vector<vector<long long int>> output(n);
        for(int i=0; i<n; i++){
            output[i].resize(i+1, 1);
            for(int j=1; j<i; j++){
                output[i][j] = output[i-1][j-1] + output[i-1][j];
            }
        }
        return output;
  
}

Q3
#include <bits/stdc++.h> 
vector<int> nextPermutation(vector<int> &permutation, int n)
{
    int ind=-1;
    for(int i=n-2;i>=0;i--)    
    {
           if(permutation[i+1]>permutation[i])
           {
               ind=i;
               break;
           }

    }
    if(ind==-1)
    {
        reverse(permutation.begin(),permutation.end());
        return permutation;
    }
    for(int i=n-1;i>=0;i--)
    {
        if(permutation[ind]<permutation[i])
        {
            swap(permutation[ind],permutation[i]);
            break;
        }
    }
    reverse(permutation.begin()+ind+1,permutation.end());
    return permutation;

}
Q4	
#include <bits/stdc++.h> 
long long maxSubarraySum(int arr[], int n)
{
    /*
        Don't write main().
        Don't read input, it is passed as function argument.    
        No need to print anything.
        Taking input and printing output is handled automatically.
    */
    long long maxi=LONG_MIN;
    long long sum=0;
    for(int i=0;i<n;i++)
    {
        sum+=arr[i];
        maxi=max(maxi,sum);
        if(sum<0)sum=0;
    }
    if(maxi<0) return 0;
    else return maxi;

    
}

Q5
#include <bits/stdc++.h> 
void sort012(int *arr, int n)
{
   //   Write your code here
   int low=0,mid=0,high=n-1;
   

   while(mid<=high)
   {
      
      if(arr[mid]==0)
      {
         swap(arr[low],arr[mid]);
         low++;
         mid++;
      
      }
      else if (arr[mid] == 1) {

        mid++;
      }

      else  {
        swap(arr[mid], arr[high]);
        
        high--;
      }
   }
   
}
Q6
#include <bits/stdc++.h> 
int maximumProfit(vector<int> &prices){
    // Write your code here.
    int profit=0,mini=prices[0];
    for(int i=1;i<prices.size();i++)
    {
        profit=max(profit,(prices[i]-mini));
        mini=min(prices[i],mini);
    }
    return profit;
   
}
Q7
#include <bits/stdc++.h>

void rotateMatrix(vector<vector<int>> &mat, int n, int m)
{
    int row = 0, col = 0; 
    int prev, curr; 
    int lastRow= n;
    int lastCol= m;
    while (row < lastRow && col < lastCol) 

    {  
        if (row + 1 == lastRow || col + 1 == lastCol)  break;   

        prev = mat[row + 1][col]; 
        
        for (int i = col; i < lastCol; i++) 
        { 
            curr = mat[row][i]; 
            mat[row][i] = prev; 
            prev = curr; 
        } 
        row++; 
        
        for (int i = row; i < lastRow; i++) 
        { 
            curr = mat[i][lastCol-1]; 
            mat[i][lastCol-1] = prev; 
            prev = curr; 
        } 
        lastCol--;   
        
        if (row < lastRow) 
        { 
            for (int i = lastCol-1; i >= col; i--) 
            { 
                curr = mat[lastRow-1][i]; 
                mat[lastRow-1][i] = prev; 
                prev = curr; 
            } 
        } 
        lastRow--; 
        
        if (col < lastCol) 
        { 
            for (int i = lastRow-1; i >= row; i--) 
            { 
                curr = mat[i][col]; 
                mat[i][col] = prev; 
                prev = curr; 
            } 
        } 
        col++; 
    } 
 
    

}
Q8
#include <bits/stdc++.h> 
/*

    intervals[i][0] = start point of i'th interval
    intervals[i][1] = finish point of i'th interval

*/

vector<vector<int>> mergeIntervals(vector<vector<int>> &arr)
{
    vector<vector<int>> ans;
     sort(arr.begin(), arr.end());

    for (int i = 0; i < arr.size(); i++) {
        
        if (ans.empty() || arr[i][0] > ans.back()[1]) {
            ans.push_back(arr[i]);
        }
        
        else {
            ans.back()[1] = max(ans.back()[1], arr[i][1]);
        }
    }
    return ans;
}
Q9
#include <bits/stdc++.h>

vector<int> ninjaAndSortedArrays(vector<int>& arr1, vector<int>& arr2, int m, int n) {
	// Write your code here.

	int left=m-1;
	int right=0;
	while(left>=0 && right<n)
	{
		if(arr2[right]<arr1[left])
		{
			swap(arr2[right],arr1[left]);
			right++;
			left--;
         } 
		else {
                  break;
                }
    }
	sort(arr1.begin(),arr1.begin()+m);
	sort(arr2.begin(),arr2.begin()+n);
	for(int i=m;i<m+n;i++)
	{
		arr1[i]=arr2[i-m];
	}
	return arr1;
}

Q10
#include <bits/stdc++.h>

int findDuplicate(vector<int> &arr, int n){
	// Write your code here.
	sort(arr.begin(),arr.end());
	for(int i=0;i<n-1;i++)
	{
		if(arr[i]==arr[i+1])
		{
			return (arr[i]);
		}
	}
}

Q11
#include <bits/stdc++.h>

pair<int,int> missingAndRepeating(vector<int> &arr, int n)
{ int hash[n+1]={0};

    

    for(int i=0;i<n;i++){

        hash[arr[i]]++;

    }

    int rep=-1,miss=-1;

    for(int i=1;i<=n;i++){

        if(hash[i]==2)

        rep=i;

        else if(hash[i]==0)

        miss=i;

 

        if(rep!=-1 && miss!=-1){

            break;

        }

    }

    return {miss,rep};

    
}
Q12
#include <bits/stdc++.h> 
long long getInversions(long long *arr, int n){
    // Write your code here.
    long long ans=0;
    for(int i=0;i<n;i++)
    {
        for(int j=i+1;j<n;j++)
        {
            if(arr[i]>arr[j])ans++;
        }
    }
    return ans;

}
Q13
bool searchMatrix(vector<vector<int>>& mat, int target) {
    int m=mat.size(),n=mat[0].size();
    for(int i=0;i<m;i++)
    {
        for(int j=0;j<n;j++)
        {
            if(mat[i][j]==target)return true;
            else if(mat[i][j]>target)return false;
        }
    }
    return false;
        
}
Q14
#include <bits/stdc++.h>

int modularExponentiation(int x, int n, int m) {
    long ans=1;

long xx=x;

while(n>0)

{

    if(n%2!=0)

    {

        ans=((ans)%m*(xx)%m)%m;

    }

    xx=((xx)%m*(xx)%m)%m;

    n=n>>1;

}

return (int)(ans%m);
	 
}
Q15
#include <bits/stdc++.h>

int findMajorityElement(int arr[], int n) {
	// Write your code here.
	int cnt=1,a=arr[0];
	for(int i=1;i<n;i++)
	{
        
		if(arr[i]==a)
		{
			cnt++;
		}
		else{
			            cnt--;
                        if (cnt == 0) {
                          a = arr[i];
                          cnt = 1;
                        }
                }





	}
	int b=0;
	for(int i=0;i<n;i++)
	{
		if(a==arr[i])
		{
			b++;
		}




	}
	if(b>n/2)return a;
	return -1;


}
Q16
#include <bits/stdc++.h>

vector<int> majorityElementII(vector<int> &arr)
{
    // Write your code here.
    unordered_map<int,int>mp;
    for(auto x:arr)mp[x]++;
    int k=arr.size()/3;
    vector<int>ans;
    for(auto x:mp)
    {
        if(x.second>k)
        {
            ans.push_back(x.first);
        }
    }
    return ans;
}
Q17
#include <bits/stdc++.h> 
int uniquePaths(int m, int n) {
	// Write your code here.
	  int path = 1;
    for (int i = n; i < (m + n - 1); i++) {
        path *= i;
        path /= (i - n + 1);
    }
    return path;
}
Q18
#include <bits/stdc++.h> 

#include <ext/pb_ds/assoc_container.hpp>

#include <ext/pb_ds/tree_policy.hpp>

using namespace __gnu_pbds;

  

#define ordered_set tree<int, null_type,less_equal<int>, rb_tree_tag,tree_order_statistics_node_update>
int reversePairs(vector<int> &arr, int n){
	// Write your code here.
		ordered_set os;

	os.insert(arr[n-1]);

	int ans = 0;

	for(int i = n-2; i >= 0; i--) {

		ans += os.order_of_key((arr[i]/2)+ arr[i]%2 );

		os.insert(arr[i]);

	}

	return ans;
}
Q19
#include <bits/stdc++.h>

vector<vector<int>> pairSum(vector<int> &arr, int s){
   // Write your code here.
   sort(arr.begin(),arr.end());
   vector<vector<int>> ans;
   for(int i=0;i<arr.size();i++)
   {
      for(int j=i+1;j<arr.size();j++)
      {
         if(arr[i]+arr[j]==s)
         {
            ans.push_back({arr[i],arr[j]});
         }
      }

   }
   return ans;

}
Q20
#include <bits/stdc++.h>

string fourSum(vector<int> nums, int target, int n) {
    // Write your code here.
      vector<vector<int>> ans;
         
        sort(nums.begin(),nums.end());
        for(int i=0;i<n;i++)
        {
            if(i>0 && nums[i]==nums[i-1])
                continue;
            for(int j=i+1;j<n;j++)
            {
                if(j>i+1 && nums[j]==nums[j-1])
                    continue;
                int k=j+1;
                int l=n-1;
                while(k<l)
                {
                    long long sum = nums[i];
                    sum += nums[j];
                    sum += nums[k];
                    sum += nums[l];
                    if(sum == target)
                    {
                        vector<int> temp={nums[i],nums[j],nums[k],nums[l]};
                        ans.push_back(temp);
                        k++;
                        l--;
                        while(k<l && nums[k]==nums[k-1]) k++;
                        while(k<l && nums[l]==nums[l+1]) l--;
                    }
                    else if (sum > target)
                        l--;
                    else
                        k++;
                    
                }
            }
        }
        if(ans.size()==0)
        return "No";
        else 
        return "Yes";
}
Q21
#include <bits/stdc++.h>

int lengthOfLongestConsecutiveSequence(vector<int> &arr, int n) {
    // Write your code here.
    sort(arr.begin(),arr.end());
    int count=1;
    int res=1;
    for(int i=1;i<n;i++)
    {
        if(arr[i]==arr[i-1] || arr[i]==arr[i-1]+1 )
        {
            if(arr[i]==arr[i-1]+1)count++;
            

        }
        else{
            count=1;
        }
        res=max(count,res);

    }
    
    return res;



}
Q22
#include <bits/stdc++.h>

int LongestSubsetWithZeroSum(vector < int > arr) {

  // Write your code here
  int ans=0;
  for(int i=0;i<arr.size();i++)
  {
    int cnt=0;
    
      for(int j=i;j<arr.size();j++)
      {
        cnt+=arr[j];
        if(cnt==0)ans=max(ans,j-i+1);

      }
    
  }
  return ans;

}
Q23
#include <bits/stdc++.h>

int subarraysXor(vector<int> &arr, int x)
{
    //    Write your code here.
    int xr=0;
    map<int,int>mp;
    mp[xr]++;
    int cnt=0;
    for(int i=0;i<arr.size();i++){
        xr=xr^arr[i];
        int y=xr^x;
        cnt+=mp[y];
        mp[xr]++;

    }
    return cnt;
}
Q24
#include <bits/stdc++.h> 
int uniqueSubstrings(string s)
{
    //Write your code here
    vector<int>mp(256,-1);
    int l=0,r=0,len=0;
    while(r<s.size()){
        if(mp[s[r]]!=-1){
            l=max(mp[s[r]]+1,l);
        }
        mp[s[r]]=r;
        len=max(len,r-l+1);
        r++;

    }
    return len;
}
Q25
#include <bits/stdc++.h>

/****************************************************************

    Following is the class structure of the LinkedListNode class:

    template <typename T>
    class LinkedListNode
    {
    public:
        T data;
        LinkedListNode<T> *next;
        LinkedListNode(T data)
        {
            this->data = data;
            this->next = NULL;
        }
    };

*****************************************************************/

LinkedListNode<int> *reverseLinkedList(LinkedListNode<int> *head) 
{
    // Write your code here
    if(head==NULL || head->next==NULL)return head;
    LinkedListNode<int> *prev=NULL; 
    LinkedListNode<int> *curr=head;
    LinkedListNode<int> *forward=head->next;
    while(curr!=NULL)
    {
        forward=curr->next;
        curr->next=prev;
        prev=curr;
        curr=forward;
        
        
        
    }  
    return prev; 
        

        

    
    
}


Q26
/*
Following is the class structure of the Node class:

class Node
{
public:
    int data;
    Node *next;
    Node()
    {
        this->data = 0;
        next = NULL;
    }
    Node(int data)
    {
        this->data = data; 
        this->next = NULL;
    }
    Node(int data, Node* next)
    {
        this->data = data;
        this->next = next;
    }
};
*/
int nodeLength(Node* head){
    int count=0;
    while(head!=NULL)
    {
        head=head->next;
        count++;
    }
    return count;
}


Node *reverse(Node *head) {
    // Write your code here
    int len=nodeLength(head);
    int ans=len/2;
    Node* temp=head;
    while(ans!=0)
    {
        temp=temp->next;
        ans--;
    }
    return temp;


}

Q27
#include <bits/stdc++.h>

/************************************************************

    Following is the linked list node structure.
    
    template <typename T>
    class Node {
        public:
        T data;
        Node* next;

        Node(T data) {
            next = NULL;
            this->data = data;
        }

        ~Node() {
            if (next != NULL) {
                delete next;
            }
        }
    };

************************************************************/

Node<int>* sortTwoLists(Node<int>* first, Node<int>* second)
{
    // Write your code here.
    if(first==NULL)return second;
    if(second==NULL)return first;
    Node<int>*l1=first,*l2=second,*temp,*res;
    if(l1->data>=l2->data)swap(l1,l2);
    res=l1;

    while(l1!=NULL && l2!=NULL)
    {
        temp=NULL;
        while(l1!=NULL && l1->data<=l2->data)
        {
            temp=l1;
            l1=l1->next;
        }
        temp->next=l2;
        swap(l1,l2);

    }
    

    return res;
    


    

}
Q 28

/*
Following is the class structure of the Node class:

class Node
{
public:
    int data;
    Node *next;
    Node()
    {
        this->data = 0;
        next = NULL;
    }
    Node(int data)
    {
        this->data = data; 
        this->next = NULL;
    }
    Node(int data, Node* next)
    {
        this->data = data;
        this->next = next;
    }
};
*/
int nodeLength(Node* head)
{
    int cnt=0;
    while(head!=NULL)
    {
        head=head->next;
        cnt++;
    }
    return cnt;
}

Node* removeKthNode(Node* head, int K)
{
    // Write your code here.
    int len=nodeLength(head);

    Node*t,* p=head;
    t=head;
    if(len-K==0)return p->next;
    
    
    while(len-K-1)
    {
        p=p->next;
        len--;
        
    }
   
   p->next=p->next->next;
//    delete(q);
    
    return t;
    

}

Q29
/**
 * Definition of linked list:
 *
 * class Node {
 * public:
 *      int data;
 *      Node *next;
 *      Node() {
 *          this->data = 0;
 *          this->next = NULL;
 *      }
 *      Node(int data) {
 *          this->data = data;
 *          this->next = NULL;
 *      }
 *      Node (int data, Node *next) {
 *          this->data = data;
 *          this->next = next;
 *      }
 * };
 *
 
 *************************************************************************/
 
 void insertAtTail(Node*  &head,Node* &tail,int digit)
 {
   Node* temp=new Node(digit);
   if(head==NULL)
   {
     head=temp;
     tail=temp;
     return;
    
   }
   else{
     tail->next=temp;
     tail=temp;
   }
   
 }
Node *addTwoNumbers(Node *num1, Node *num2)
{
    // Write your code here.
    
    
    
    Node* dummy=NULL,*temp=NULL;
    int carry=0;
    while(num1!=NULL || num2!=NULL || carry)
    {
      int sum=0;
      if(num1!= NULL)
      {
        sum+=num1->data;
        num1=num1->next;
        
      }
      if(num2!= NULL)
      {
        sum+=num2->data;
        num2=num2->next;
        
      }
      sum+=carry;
      carry=sum/10;
      sum%=10;
      
      insertAtTail(dummy,temp,sum);
      
      
        
      
      
      
    }
    
    return dummy;
}
Q30
#include <bits/stdc++.h>

/****************************************************************

    Following is the class structure of the LinkedListNode class:

    template <typename T>
    class LinkedListNode
    {
    public:
        T data;
        LinkedListNode<T> *next;
        LinkedListNode(T data)
        {
            this->data = data;
            this->next = NULL;
        }
    };

*****************************************************************/

void deleteNode(LinkedListNode<int> * node) {
    // Write your code here.
    if(node==NULL)return;
    if(node->next==NULL)
    {
        node=NULL;
        return;
    }
    node->data=node->next->data;
    LinkedListNode<int> *temp=node->next;
    node->next=temp->next;
    delete temp;

}
Q31
/****************************************************************

    Following is the class structure of the Node class:

        class Node
        {
        public:
            int data;
            Node *next;
            Node()
            {
                this->data = 0;
                next = NULL;
            }
            Node(int data)
            {
                this->data = data;
                this->next = NULL;
            }
            Node(int data, Node* next)
            {
                this->data = data;
                this->next = next;
            }
        };

*****************************************************************/

Node* findIntersection(Node *head1, Node *head2)
{
    //Write your code here
    if(head1==NULL || head2==NULL)return NULL;
    Node *d1=head1,*d2=head2;
    while(d1!=d2)
    {
        d1=(d1==NULL)?head2:d1->next;
        d2=(d2==NULL)?head1:d2->next;

    }
    
    

    return d1;
}
Q32
/****************************************************************

    Following is the class structure of the Node class:

        class Node
        {
        public:
            int data;
            Node *next;
            Node()
            {
                this->data = 0;
                next = NULL;
            }
            Node(int data)
            {
                this->data = data;
                this->next = NULL;
            }
            Node(int data, Node* next)
            {
                this->data = data;
                this->next = next;
            }
        };


*****************************************************************/

bool detectCycle(Node *head)
{
	//	Write your code here
    if(head == NULL ||  head->next==NULL)return false;
    Node* s=head,*f=head;
    while(f->next && f->next->next)
    {
        
        s=s->next;
        f=f->next->next;
        if(s==f)return true;

    }
    return false;
}
Q33
#include <bits/stdc++.h>

/****************************************************************

    Following is the class structure of the Node class:

        class Node
        {
        public:
	        int data;
	        Node *next;
	        Node(int data)
	        {
		        this->data = data;
		        this->next = NULL;
	        }
        };

*****************************************************************/
int calc(Node *head){
	Node*p=head;
	int l=0;
	while(p){
		l++;
		p=p->next;
	}
	return l;
}

Node *reverse(Node *head) {
  Node *p = head, *nxt, *prev = NULL;

  while (p) {
    nxt = p->next;
    p->next = prev;

    prev = p;
    p = nxt;
  }

  return prev;
}


Node *getListAfterReverseOperation(Node *head, int n, int b[]){
	// Write your code here.
	Node*dummy=new Node(0);

	dummy->next=head;
    Node*p=dummy,*curr,*nxt;
	if(head==NULL || head->next==NULL)return head;
	int len=calc(head);
	for(int i=0;i<n;i++){
		if(len==0)break;
		if(b[i]<=len){
			curr=p->next;
			nxt=curr->next;

			if(b[i]==0)continue;
			for(int j=0;j<b[i]-1;j++)
			{
				curr->next=nxt->next;
				nxt->next=p->next;
				p->next=nxt;
				nxt=curr->next;

			}
			len-=b[i];
			p=curr;


		}
		else if(len<=b[i])
		{
			p->next=reverse(p->next);
			len=0;
		}
	}



    return dummy->next;
	


}
Q34

#include <bits/stdc++.h> 
/****************************************************************

    Following is the class structure of the LinkedListNode class:

    template <typename T>
    class LinkedListNode
    {
    public:
        T data;
        LinkedListNode<T> *next;
        LinkedListNode(T data)
        {
            this->data = data;
            this->next = NULL;
        }
    };

*****************************************************************/
LinkedListNode<int>*reverse(LinkedListNode<int>*head)
{
    LinkedListNode<int>*curr=head,*forward=head,*newhead=NULL;
    while(curr!=NULL)
    {
        forward=curr->next;curr->next=newhead;
        newhead=curr;
        curr=forward;
        

        
    }
    return newhead;
}

bool isPalindrome(LinkedListNode<int> *head) {
    // Write your code here.
    if(head==NULL ||head->next==NULL )return true;
    LinkedListNode<int>* s=head,*f=head,*d=head;
    while(f->next && f->next->next)
    {
        s=s->next;
        f=f->next->next;
    }
    s->next=reverse(s->next);
    s=s->next;
    while(s!=NULL)
    {
        if(s->data!=d->data)return false;
        s=s->next;
        d=d->next;
    }
    return true;


}
Q 35

/****************************************************************

    Following is the class structure of the Node class:

        class Node
        {
        public:
            int data;
            Node *next;
            Node()
            {
                this->data = 0;
                next = NULL;
            }
            Node(int data)
            {
                this->data = data;
                this->next = NULL;
            }
            Node(int data, Node* next)
            {
                this->data = data;
                this->next = next;
            }
        };


*****************************************************************/

Node *firstNode(Node *head)
{
    //    Write your code here.
    if(head==NULL || head->next==NULL)return NULL;
    Node *s=head,*f=head,*entry=head;
    
    while(f->next && f->next->next)
    {
        s=s->next;
        f=f->next->next;
        
        if(s==f){
            if(s==entry)return s;
            while(true)
            {
                s=s->next;
                entry=entry->next;
                if(s==entry)return entry;
                
            }

        }
     }
     return NULL;

}
Q36
/*
 * Definition for linked list.
 * class Node {
 *  public:
 *		int data;
 *		Node *next;
 * 		Node *child;
 *		Node() : data(0), next(nullptr), child(nullptr){};
 *		Node(int x) : data(x), next(nullptr), child(nullptr) {}
 *		Node(int x, Node *next, Node *child) : data(x), next(next), child(child) {}
 * };
 */

Node* mergeTwoLists(Node* a, Node* b) {

    

    Node *temp = new Node(0);

    Node *res = temp; 

    

    while(a != NULL && b != NULL) {

        if(a->data < b->data) {

            temp->child = a; 

            temp = temp->child; 

            a = a->child; 

        }

        else {

            temp->child = b;

            temp = temp->child; 

            b = b->child; 

        }

    }

    

    if(a) temp->child = a; 

    else temp->child = b; 

    

    return res -> child; 

    

}

Node* flattenLinkedList(Node* head) 

{

    if(head == NULL || head->next == NULL) return head;

 

    Node* L2 = flattenLinkedList(head->next);

    head->next = NULL;

    Node* nhead = mergeTwoLists(head, L2);

    return nhead;

}

 

Q37
/**
 * Definition for singly-linked list.
 * class Node {
 * public:
 *     int data;
 *     Node *next;
 *     Node() : data(0), next(nullptr) {}
 *     Node(int x) : data(x), next(nullptr) {}
 *     Node(int x, Node *next) : data(x), next(next) {}
 * };
 */
 

Node *rotate(Node *head, int k) {
     // Write your code here.
     if(head==NULL || head->next==NULL || k==0)return head;
     Node*q=head;
     int len=1;
     while(q->next && ++len)
     {   
          q=q->next;
     }
     q->next=head;
     k=k % len;
     k=len-k;
     while(k--)
     {
          q=q->next;
     }
     head=q->next;
     q->next=NULL;
     return head;
}
Q38
#include <bits/stdc++.h>

/*************************************************************

    Following is the LinkedListNode class structure

    template <typename T>   
    class LinkedListNode
    {
        public:
        T data;
        LinkedListNode<T> *next;
        LinkedListNode<T> *random;
        LinkedListNode(T data)
        {
            this->data = data;
            this->next = NULL;
        }
    };

*************************************************************/
void insertAtTail(LinkedListNode<int> *&head, LinkedListNode<int> *&tail, int value)

{

    LinkedListNode<int> *newNode=new LinkedListNode<int>(value);

    if(head==NULL)

    {

        head=newNode;

        tail=newNode;

    }

    else{

        tail->next=newNode;

        tail=newNode;

    }

}

LinkedListNode<int> *cloneRandomList(LinkedListNode<int> *head)

{

    if(head==NULL)

    {

        return head;

    }

    LinkedListNode<int> *cloneHead=NULL;

    LinkedListNode<int> *cloneTail=NULL;

    LinkedListNode<int> *temp=head;

    while(temp)

    {

        insertAtTail(cloneHead, cloneTail, temp->data);

        temp=temp->next;

    }

    LinkedListNode<int> *originalNode=head;

    LinkedListNode<int> *cloneNode=cloneHead;

    while(originalNode && cloneNode)

    {

        LinkedListNode<int> *forward1=originalNode->next;

        originalNode->next=cloneNode;

        originalNode=forward1;

        LinkedListNode<int> *forward2=cloneNode->next;

        cloneNode->next=originalNode;

        cloneNode=forward2;

    }

    temp=head;

    cloneNode=cloneHead;

    while(temp)

    {

        if(temp->next!=NULL)

        {

            if(temp->random!=NULL)

            {   

                temp->next->random=temp->random->next;

            }

            else

            {

                temp->next->random=temp->random;

            }

            temp=temp->next->next;

        }

    }

    originalNode=head;

    cloneNode=cloneHead;

    while(originalNode && cloneNode)

    {

        originalNode->next=cloneNode->next;

        originalNode=originalNode->next;

        if(originalNode!=NULL)

        {

            cloneNode->next=originalNode->next;

            cloneNode=cloneNode->next;

        }

    }

    return cloneHead;

}
Q39
#include <bits/stdc++.h> 
vector<vector<int>> findTriplets(vector<int>nums, int n, int K) {
	// Write your code here.
	if(n<3)return {};

	vector<vector<int>> triplets;

    sort(nums.begin(), nums.end());

	for(int i = 0; i<n-2; i++){
        int start = i+1;
        int end = n-1;
        while(start<end){
                
            int sum = nums[i] + nums[start] + nums[end];
            if(sum == K){
                triplets.push_back({nums[i], nums[start], nums[end]});
                start++;
                end--;
                while(start<n && nums[start] == nums[start-1]){
					start++;
				}
					
                while(end>i && nums[end] == nums[end+1]){
					end--;
				}	
            }
			else if(sum>K){
                end--;
            } 
			else {
              start++;
            }
        }
        while (i < n - 1 && nums[i] == nums[i + 1])
          i++;
    }
    return triplets;
}
Q40
#include<bits/stdc++.h>
#include<algorithm>
long long getTrappedWater(long long* arr, int n) {
    // Write your code here.
    if(n==1)return 0;
    vector<long long>left(n,-1);
    vector<long long>right(n,-1);
    
    left[0]=arr[0];
    right[n-1]=arr[n-1];
    for(int i=1;i<n;i++){
        left[i]=max(left[i-1],arr[i]);

    }
    for(int i=n-2;i>=0;i--){
        right[i]=max(right[i+1],arr[i]);
    }

    long ans=0;
    for(int i=0;i<n;i++){
        ans+=min(left[i],right[i])-arr[i];
    }
    return ans;

}
Q41
#include<bits/stdc++.h>
int removeDuplicates(vector<int> &arr, int n) {
	// Write your code here.
    
	int i=1;
	for(int j=1;j<n;j++)
	{
		if(arr[j]!=arr[j-1])
		{
			i++;
		}

	}
	return i;
}
Q42
int longestSubSeg(vector<int> &arr , int n, int k){
    // Write your code here.
    int flip=0;
    int ans=0;
    int i=0;
    int j=0;
    while(j<n)
    {
        if(arr[j]==0){
            flip++;
            
        }
        while(flip>k){
            if(arr[i]==0)
            {
                flip--;
            }
            i++;
        }
        ans=max(ans,j-i+1);
        j++;
        

    }
    return ans;
}
Q43
#include <bits/stdc++.h>
struct meeting{
    int start;
    int end;
    int pos;
};
bool comparator(struct meeting m1,meeting m2){
    if(m1.end<m2.end)return true;
    else if(m1.end>m2.end)return false;
    else if(m1.pos<m2.pos)return true;
    return false;
}




vector<int> maximumMeetings(vector<int> &star, vector<int> &en) {
    // Write your code here.
    int n=star.size();


    struct meeting meet[n];
    for(int i=0;i<n;i++){
        meet[i].start=star[i];
        meet[i].end=en[i];
        meet[i].pos=i+1;
    }
    sort(meet,meet+n,comparator);
    int limit=meet[0].end;
    vector<int>ans;
    ans.push_back(meet[0].pos);
    for(int i=1;i<n;i++)
    {
        if(limit<meet[i].start)
        {
            limit=meet[i].end;
            ans.push_back(meet[i].pos);

        }
    }
    return ans;
}
Q44

int deleteElement(int arr[], int n, int x)
{

int i;
for (i=0; i<n; i++)
    if (arr[i] == x)
        break;
if (i < n)
{
    n = n - 1;
    for (int j=i; j<n; j++)
        arr[j] = arr[j+1];
}
return n;
}
int calculateMinPatforms(int at[], int dt[], int n) {
    for(int i=0;i<n;i++)
    {
        if(dt[i]<at[i]){
            n=deleteElement(at,n,at[i]);
            n=deleteElement(dt,n,dt[i]);
        }
    }
    // Write your code here.
    int plat=0,free=0,full=0,j=0;

    sort(at,at+n);
    sort(dt,dt+n);

    for(int i=0;i<n;i++){
            if(plat==full){
                plat++;
                full++;

            }
            else{
              if (free > 0) {
                free--;
                full++;
              }
              
            }        
        if(dt[j]<at[i+1]){
            j++;
            free++;
            full--;
        }
    }
    return plat;

}
Q45
#include <bits/stdc++.h> 
bool comparator(vector<int>j1,vector<int>j2) {
    return j1[1]>j2[1] || (j1[1]==j2[1] && j1[0]>=j2[0]);
}
int jobScheduling(vector<vector<int>> &jobs)
{
    // Write your code here
    int n=jobs.size();
    sort(jobs.begin(),jobs.end(),comparator);
    int maxdeadline=-1,profit=0;
    for(int i=0;i<n;i++){
        maxdeadline=max(maxdeadline,jobs[i][0]);
    }
    vector<int>ans(maxdeadline+1,-1);
    for(int i=0;i<n;i++){
        int dummy=jobs[i][0];
        for(int j=dummy;j>0;j--){
            if(ans[j]==-1){
                ans[j]=jobs[i][1];
                profit+=jobs[i][1];
                

                break;
            }
        }
    }

    return profit;
}
Q46
#include <bits/stdc++.h> 
bool comparator(pair<int,int> a,pair<int,int>b)
{
    double r1=(double)a.second/(double)a.first;
    double r2=(double)b.second/(double)b.first;
    return r1>r2;
}
double maximumValue (vector<pair<int, int>>& items, int n, int w)
{
    // Write your code here.
    // ITEMS contains {weight, value} pairs.

  
    sort(items.begin(),items.end(),comparator);
    double count=0;int j=0;
    while(w && j<n){
        if(w>=items[j].first){
            count+=items[j].second;
            w-=items[j].first;

        }
        else{
            count+=(double)(w)*items[j].second/items[j].first;
            break;
        }
        j++;
        



    }
    return count;







}
Q47
#include <bits/stdc++.h> 
int findMinimumCoins(int amount) 
{
    // Write your code here
    int arr[9]={1,2,5,10,20,50,100,500,1000};
    int coins=0;
    for(int i=8;i>=0;i--){
        coins+=amount/arr[i];
        amount=amount%arr[i];
    }
    return coins;
}
Q48
#include <bits/stdc++.h>

struct Interval {
    int start, end;
};
  

bool compareInterval(Interval i1, Interval i2)
{
    return(i1.end<i2.end);
}
int maximumActivities(vector<int> &star, vector<int> &en) {
    // Write your code here.
    int n=star.size();
    struct Interval ans[n];
    for(int i=0;i<n;i++){
        ans[i].start=star[i];
        ans[i].end=en[i];
    }
    sort(ans,ans+n,compareInterval);
    int count=1,limit=ans[0].end;

    for(int i=1;i<n;i++)
    {
        if(limit<=ans[i].start)
        {
            count++;
            limit=ans[i].end;
        }



    }
    return count;

}
Q49
#include <bits/stdc++.h> 
void recursion(vector<int>& num,vector<int> &ans,int sum,int i,int n)
{
    if(i==n){
        ans.push_back(sum);
        return;
    }
    recursion(num,ans,sum+num[i],i+1,n);
    recursion(num,ans,sum,i+1,n);
    
}
vector<int> subsetSum(vector<int> &num)
{
    // Write your code here.
    int n=num.size();
    
    vector<int>ans;
    
    recursion(num,ans,0,0,n);
    sort(ans.begin(),ans.end());
    
   
    return ans;


}
Q50
#include <bits/stdc++.h> 
void recursion(vector<vector<int>> &ans,vector<int> &dp,vector<int> &arr,int ind){
    ans.push_back(dp);
    for(int i=ind;i<arr.size();i++)
    {
        if(i!=ind && arr[i]==arr[i-1])
        {
            continue;
            }
        dp.push_back(arr[i]);
        recursion(ans,dp,arr,i+1);
        dp.pop_back();
    }
}

vector<vector<int>> uniqueSubsets(int n, vector<int> &arr)
{
    // Write your code here.
    sort(arr.begin(),arr.end());
   vector<vector<int>>ans;
   vector<int>dp;
   recursion(ans,dp,arr,0);
   return ans;
}
Q51
void recursion(vector<int> &arr,vector<vector<int>>&ans,vector<int>dp,int ind,int k,int n)
{
    int sum=0;
    for(int i=0;i<dp.size();i++)
    {
        sum+=dp[i];

    }
    if(sum==k)ans.push_back(dp);
    for(int i=ind;i<n;i++)
    {
       
        dp.push_back(arr[i]);
        recursion(arr,ans,dp,i+1,k,n);
        dp.pop_back();
    }
}
vector<vector<int>> findSubsetsThatSumToK(vector<int> arr, int n, int k)
{
    // Write your code here.
    
    vector<vector<int>>ans;
    vector<int>dp;
    recursion(arr,ans,dp,0,k,n);
    return ans;

}
Q52
#include<algorithm>
void findCombs(int index , int target , vector<int> &arr, vector<int> &ds, vector<vector<int>> &res){

	//BASE CASE
	if(target == 0){
		res.push_back(ds);							
		return;  					
	}

        for (int i = index; i < arr.size(); i++) {
		// CONDITION TO AVOID DUPLICATE ENTRIES AND COMBINATIONS
          if (i > index and arr[i] == arr[i - 1]) {
            continue; 
          }
		// OPTIMISING BY BREAKING LOOP AND INITIALISING A NEW ELEMENT  AS A STARTING POINT
          if (arr[i] > target) {
            break;
          }
          ds.push_back(arr[i]);

          findCombs(i + 1, target-arr[i], arr, ds, res);
		  /* THE ELEMENT IS REMOVED SO THAT A NEW COMBINATION CAN BE GENERATED
		   WHEN RECURSION CALL IS BACK-TRACKED */
		  ds.pop_back(); 
        }
}
vector<vector<int>> combinationSum2(vector<int> &arr, int n, int target)
{
	// Write your code here.

	sort(arr.begin(),arr.end());
	vector<int> ds;
	vector<vector<int>> res;
	findCombs(0, target, arr, ds, res);
	
	return res;
}
Q53
#include <bits/stdc++.h> 
bool isPalindrome(int start,int end,string&s){
    while(start<=end){
        if(s[start++]!=s[end--]){
          return false;}
    }
    return true;
}
void recursion(string &s,vector<vector<string>>&ans,vector<string>&dp,int ind){
    if(ind==s.length()){
        
        ans.push_back(dp);
        return;
    }
    for(int i=ind;i<s.length();++i)
    {
        if(isPalindrome(ind,i,s)){
            dp.push_back(s.substr(ind,i-ind+1));
            recursion(s,ans,dp,i+1);
            dp.pop_back();



        }
    }
}

vector<vector<string>> partition(string &s) 
{
    // Write your code here.
    vector<vector<string>>ans;
    vector<string>dp;
    recursion(s,ans,dp,0);


    return ans;


}
Q54
string kthPermutation(int n, int k) {
    int fact = 1;
      vector < int > numbers;
      for (int i = 1; i < n; i++) {
        fact = fact * i;
        numbers.push_back(i);
      }
      numbers.push_back(n);
      string ans = "";
      k = k - 1;
      while (true) {
        ans = ans + to_string(numbers[k / fact]);
        numbers.erase(numbers.begin() + k / fact);
        if (numbers.size() == 0) {
          break;
        }

        k = k % fact;
        fact = fact / numbers.size();
      }
      return ans;
   
  
}
Q55
string kthPermutation(int n, int k) {
    int fact = 1;
      vector < int > numbers;
      for (int i = 1; i < n; i++) {
        fact = fact * i;
        numbers.push_back(i);
      }
      numbers.push_back(n);
      string ans = "";
      k = k - 1;
      while (true) {
        ans = ans + to_string(numbers[k / fact]);
        numbers.erase(numbers.begin() + k / fact);
        if (numbers.size() == 0) {
          break;
        }

        k = k % fact;
        fact = fact / numbers.size();
      }
      return ans;
   
  
}
Q56
#include <bits/stdc++.h>
using namespace std;

void solve(int col, int n, vector<vector<int>> &res, vector<vector<int>> &mat,
           vector<int> &leftRow, vector<int> &lowerDiagonal,
           vector<int> &upperDiagonal) {
  if (col == n) {
    vector<int> ans;
    for (auto i : mat)
      for (auto j : i)
        ans.push_back(j);

    res.push_back(ans);
    return;
  }

  for (int i = 0; i < n; i++) {
    if (leftRow[i] == 0 and lowerDiagonal[i + col] == 0 and
        upperDiagonal[(n - 1) + (col - i)] == 0) {
      leftRow[i] = 1;
      lowerDiagonal[i + col] = 1;
      upperDiagonal[(n - 1) + (col - i)] = 1;
      mat[i][col] = 1;

      solve(col + 1, n, res, mat, leftRow, lowerDiagonal, upperDiagonal);

      leftRow[i] = 0;
      lowerDiagonal[i + col] = 0;
      upperDiagonal[(n - 1) + (col - i)] = 0;
      mat[i][col] = 0;
    }
  }
}

vector<vector<int>> solveNQueens(int n) {
  vector<vector<int>> res;
  vector<vector<int>> mat(n, vector<int>(n));

  vector<int> leftRow(n), lowerDiagonal(2 * n - 1), upperDiagonal(2 * n - 1);

  solve(0, n, res, mat, leftRow, lowerDiagonal, upperDiagonal);
  return res;
}
Q57
bool valid(int i,int j,int k,int matrix[9][9]){
    for(int m=0;m<9;m++){
        if(matrix[m][j]==k)return false;
        else if(matrix[i][m]==k)return false;
        else if(matrix[3*(i/3)+m/3][3*(j/3)+m%3]==k)return false;
    }
    return true;

}
bool solve(int matrix[9][9]){
    for(int i=0;i<9;i++)
    {
        for(int j=0;j<9;j++)
        {
            if(matrix[i][j]==0){
                for(int k=1;k<=9;k++){
                   if(valid(i,j,k,matrix))
                   {matrix[i][j]=k;
                    if(solve(matrix))return true;
                    else matrix[i][j]=0;
                    
                    }
                }
                return false;
            }
            

        }
    }
    return true;
}
bool isItSudoku(int matrix[9][9]) {

    // Write your code here.
    solve(matrix);
   
}
Q58
#include <bits/stdc++.h>

bool isSafe(int node, int v, int color, vector<int> &colorOfNode, vector<vector<int>> &mat){
    for(int i = 0; i < v; i++){
        if(mat[node][i] == 1){
            if(colorOfNode[i] == color){
                return false;
            }
        }
    }

    colorOfNode[node] = color;
    return true;
}

bool solve(int node, int v, int m, vector<int> &colorOfNode, vector<vector<int>> &mat){
    if(node == v){
        return true;
    }
    
    for(int i = 1; i <= m; i++){
        if(isSafe(node, v, i, colorOfNode, mat)){
            if(solve(node+1, v, m, colorOfNode, mat)){
                return true;
            }
            colorOfNode[node] = 0;
        }
    }

    return false;
}

string graphColoring(vector<vector<int>> &mat, int m) {
    int v = mat.size();
    vector<int> colorOfNode(v, 0);

    if(solve(0, v, m, colorOfNode, mat)){
        return "YES";
    }
    return "NO";
}
Q59
#include <bits/stdc++.h> 
void recursion(vector<vector<int>>&maze,int n,vector<vector<int>>&ans,int row,int col,vector<vector<int>>&vis){

  
  
    if (row == n-1 && col == n-1 ) {
      vector<int>temp;
      vis[row][col]=1;
      for(int i=0;i<n;i++)
      {
        for(int j=0;j<n;j++)
        {
          temp.push_back(vis[i][j]);
        }
      }
      vis[row][col]=0;
      ans.push_back(temp);

      
      return;
    }

    if (row-1>=0 && maze[row - 1][col] == 1 && !vis[row - 1][col]) {
      
      vis[row - 1][col] = 1;
      recursion(maze, n, ans, row - 1, col, vis);
      vis[row - 1][col] = 0;
      
    }
    if (col-1>=0 &&maze[row][col - 1] == 1 && !vis[row][col - 1]) {
      
      vis[row][col - 1] = 1;
      recursion(maze, n, ans,  row, col - 1, vis);
      vis[row][col - 1] = 0;
      
    }
    if (col+1<n&&maze[row][col + 1] == 1 && !vis[row][col + 1]) {
      
      vis[row][col + 1] = 1;
      recursion(maze, n, ans, row, col + 1, vis);
      vis[row][col + 1] = 0;
      
    }

    if (row+1<n&&maze[row + 1][col] == 1 && !vis[row + 1][col]) {
      
      vis[row + 1][col] = 1;
      recursion(maze, n, ans,  row + 1, col, vis);
      vis[row + 1][col] = 0;
      
    }
}


vector<vector<int> > ratInAMaze(vector<vector<int> > &maze, int n){
  // Write your code here.
   vector < vector < int >> vis(n, vector < int > (n, 0));
  vector<vector<int>>ans;
  
  if(maze[0][0])vis[0][0]=1;recursion(maze,n,ans,0,0,vis);
  return ans;


}
Q60
#include <bits/stdc++.h> 

 

void f(int idx,string t,string &s,unordered_map<string,int> &mp,vector<string> &ans)

{

    if(idx==s.length())

    {

        ans.push_back(t);

        return;

    }

 

    string a;

    for(int i=idx;i<s.length();i++)

    {

        a+=s[i];

        if(mp.find(a)!=mp.end())

        {

            if(t.length()==0)

              f(i+1,t+a,s,mp,ans);

            else

              f(i+1,t+" "+a,s,mp,ans);

        }

    }

}

 

vector<string> wordBreak(string &s, vector<string> &words)

{

    // Write your code here

    unordered_map<string,int> mp;

    for(auto it:words)

      mp[it]++;

    

    vector<string> ans;

    string t;

    f(0,t,s,mp,ans);

    return ans;

 

}
Q61
int NthRoot(int n, int m) {
  // Write your code here.
  int low=1;
  int high=m;
  
  while(high-low >=0)
  {
    int mid=(low+high)/2;
    if(pow(mid,n)==m)return mid;
    else if(pow(mid,n)<m){
      low=mid+1;
    }
    else{
      high=mid-1;
    }
  }
  return -1;
  

  
}
Q62
#include<bits/stdc++.h>
int countsmallerThanMid(vector<int>&row,int mid){
    int l=0,h=row.size()-1;
    while(l<=h){
        int md=(l+h)>>1;
        if(row[md]<=mid){
            l=md+1;
        }
        else {
            h=md-1;
        }
    }
    return l;
}
int getMedian(vector<vector<int>> &matrix)
{
    // Write your code here.
    int low=1;
    int high=1e9;
    int n=matrix.size();
    int m=matrix[0].size();
    while(low<=high){
        int mid=(low+high)>>1;
        int cnt=0;
        for(int i=0;i<n;i++){
            cnt+=countsmallerThanMid(matrix[i],mid);
        }
        if(cnt<=(n*m)/2){
            low=mid+1;
        }
        else{
            high=mid-1;
        }

    }
    return low;
    }
Q63
int singleNonDuplicate(vector<int>& arr)
{
	// Write your code here

	int low  = 0, high = arr.size() - 1;

    // Edge case - Only one element

    if(high == 0)

        return arr[0];

 

    // Edge case - Ans is first or last element

    if(arr[0]!=arr[1])

        return arr[0];

    else if(arr[high] != arr[high-1])

        return arr[high];  

    while(low <= high){

        int mid = low + (high-low)/2;

 

        // If mid is the single element

        if(arr[mid] != arr[mid-1] && arr[mid] != arr[mid+1])

            return arr[mid];

        // If mid is odd, the single element lies on the other side

        if(mid % 2 == 1){

            if(arr[mid] == arr[mid-1])

                low = mid+1;

            else

                high = mid-1;

        }  

 // If mid is even, the single element lies on the same side

        else{

            if(arr[mid] == arr[mid-1])

                high = mid-2;

            else

                low = mid+2;

        }

    }        


}
Q64
int search(int* arr, int n, int key) {
    // Write your code here.
    int low=0,high=n-1;
    while(low<=high){
        int mid=(low+high)>>1;
        if(arr[mid]==key)return mid;
        if(arr[low]<=arr[mid]){
            if(arr[low]<=key and arr[mid]>key){
                high=mid-1;
            }
            else{
                low=mid+1;
            }
        }
        else{
            if(key>arr[mid] and arr[high]>=key){
                low=mid+1;
            }
            else{
                high=mid-1;
            }
        }
    }
    return -1;
}
Q65
#include<bits/stdc++.h>
double median(vector<int>& a, vector<int>& b) {
	// Write your code here.
        if (a.size() > b.size()) {
          median(b, a);
        }
        int n1=a.size(),n2=b.size();
	int low=0;
	int high=n1;
	while(low<=high){
		int cut1=low+(high-low)/2;
		int cut2=(n1+n2+1)/2-cut1;
		int left1=(cut1==0)?INT_MIN:a[cut1-1];
		int left2=(cut2==0)?INT_MIN:b[cut2-1];
		int right1=(cut1==n1)?INT_MAX:a[cut1];
		int right2=(cut2==n2)?INT_MAX:b[cut2];
        if(left1<=right2 && left2<=right1){
			if((n1+n2)%2==0){
				return ((max(left1,left2))+(min(right1,right2)))/2.0;
			}
			else{
				return max(left1,left2);
			}
		}
		else if(left1>right2){
			high=cut1-1;

		}
		else{
			low=cut1+1;
		}

	}
	
}
Q66
//bruteforce int ninjaAndLadoos(vector<int> &row1, vector<int> &row2, int m, int n, int k) {
//     // Write your code here.
//     int i=0,j=0,ans=0;
    
//     while(k){
//         if(i<n and j<n){
//           if (row1[i] < row2[j]) {
//             ans = row1[i];
//             i++;
//           }
//           else {
//              ans = row2[j];
//              j++;
//          }
//         } 
//         else if(i<n){
//           ans = row1[i];
//           i++;
//         }
//         else{
//             ans=row2[j];
//             j++;

//         }
//         k--;

//     }
//     return ans;
// }
#include<bits/stdc++.h>
int ninjaAndLadoos(vector<int> &a, vector<int> &b, int m, int n, int k){
    if(m>n) ninjaAndLadoos(b,a,n,m,k);
    int low=max(0,k-n),high=min(k,m);
    while(low<=high){
        int cut1=(low+high)>>1;
        int cut2=k-cut1;
        
		int left1=(cut1==0)?INT_MIN:a[cut1-1];
		int left2=(cut2==0)?INT_MIN:b[cut2-1];
		int right1=(cut1==m)?INT_MAX:a[cut1];
		int right2=(cut2==n)?INT_MAX:b[cut2];
        if(left1<=right2 and left2<=right1){
            return max(left1,left2);
        }
        else if(left1>right2){
            high=cut1-1;
        }
        else{
            low=cut1+1;
        }
    }

}
Q67
#include <bits/stdc++.h> 

 

bool valid(int n, int m,vector<int> time,long long a)

{

    int cnt=0;

    long long sum=0;

    for(int i=0;i<m;i++)

    {

        if(sum+time[i]<=a)

          sum+=time[i];

        else

        {

            cnt++;

            sum=time[i];

        }

    }

 

    return  cnt<n;

 

}

 

long long ayushGivesNinjatest(int n, int m, vector<int> time) 

{   

    // Write your code here.

    long long sum=0;

    int maxi=0;

    for(auto it:time)

    {

        sum+=it;

        maxi=max(maxi,it);

    }

 

    long long ans=0;

    long long low=maxi,high=sum;

    while(low<=high)

    {

        long long mid=(low+high)/2;

        if(valid(n,m,time,mid))

        {

            ans=mid;

            high=mid-1;

        }

        else

          low=mid+1;

    }

    return ans;

}
Q68
#include <bits/stdc++.h>
bool canAssign(int c, int mid, vector<int> &positions) {
  int allot = 1, player = positions[0];
  for (int i = 1; i < positions.size(); i++) {
    if (positions[i] - player >= mid) {
      allot++;
      player = positions[i];
    }

    if (allot == c)
      return true;
  }

  return false;
}

int chessTournament(vector<int> &positions, int n, int c) {
  sort(positions.begin(), positions.end());
  int low = 1, high = positions[n - 1] - positions[0];
  int ans = -1;

  while (low <= high) {
    int mid = low + (high - low) / 2;
    if (canAssign(c, mid, positions)) { // minimum distance
      ans = mid;
      low = mid + 1;
    } else
      high = mid - 1;
  }
  return ans;
}
Q69
#include <bits/stdc++.h>
#include<queue>

vector<int> minHeap(int n, vector<vector<int>>& q) {
    // Write your code here.
    vector<int>ans;
    priority_queue<int,vector<int>,greater<int>>pq;
    for(int i=0;i<n;i++){
        if(q[i][0]==0){
            pq.push(q[i][1]);
        }
        else{
            ans.push_back(pq.top());
            pq.pop();
            
            
        }

    }
    return ans;
}

Q70
// #include<queue>
// vector<int> kthSmallLarge(vector<int> &arr, int n, int k)
// {
// 	// Write your code here.
// 	vector<int>ans;
	
// 	priority_queue<int>pmax;
// 	priority_queue<int,vector<int>,greater<int>>pmin;
//         for (int i = 0; i < n; i++) {
//           pmax.push(arr[i]);
// 		  pmin.push(arr[i]);
//         }
//         int i=k-1,j=i;
// 	while(i>0)
// 	{
// 		pmin.pop();
// 		i--;
	
		
// 	}
// 	ans.push_back(pmin.top());
// 	while(j>0){
// 		pmax.pop();
// 		j--;
// 	}
// 	ans.push_back(pmax.top());
	
// 	return ans;
// }
#include<math.h>

#include<bits/stdc++.h>

#include<iostream>

vector<int> kthSmallLarge(vector<int> &arr, int n, int k)

{

    // Write your code here.

    sort(arr.begin(),arr.end());

    return {arr[k-1],arr[n-k]};

}
Q71
#include <bits/stdc++.h> 
vector<int> kMaxSumCombination(vector<int> &a, vector<int> &b, int n, int k){
	// Write your code here.
	priority_queue<int>pq;
	for(int i=0;i<n;i++){
		for(int j=0;j<n;j++){
			pq.push(a[i]+b[j]);

		}
	}
	vector<int>ans;
	while(k--){
		ans.push_back(pq.top());
		pq.pop();

	}
	return ans;

}
Q72
#include<queue>
#include<bits/stdc++.h>
void findMedian(int *arr, int n)
{
    // Write your code here
    priority_queue<int>pmax;
    priority_queue<int,vector<int>,greater<int>>pmin;
    for(int i=0;i<n;i++){
        if(pmax.empty() or pmax.top()>=arr[i]){
            pmax.push(arr[i]);
        }
        else{
            pmin.push(arr[i]);
        }
        if(pmax.size()>pmin.size()+1)
        {
            pmin.push(pmax.top());
            pmax.pop();
        }
        else if(pmin.size()>pmax.size())
        {
            pmax.push(pmin.top());
            pmin.pop();
        }
        
         
        
        if(pmax.size()>pmin.size()){
                cout<<pmax.top()<<" ";
            }
        else{
                cout<<(pmin.top()+pmax.top())/2<<" ";
            }   
        
    }
    
}
Q73
#include <bits/stdc++.h>
#include<queue> 
vector<int> mergeKSortedArrays(vector<vector<int>>&kArrays, int k)
{
    // Write your code here.
     vector<int>ans;
    priority_queue<int,vector<int>,greater<int>>pq; 
    
   for(auto i:kArrays){
       for(auto j:i){
           pq.push(j);
       }
   }
   


    while(!pq.empty()){
        ans.push_back(pq.top());
        pq.pop();

    }
    return ans;

    
}

Q74
#include <bits/stdc++.h> 
vector<int> KMostFrequent(int n, int k, vector<int> &arr)
{
    // Write your code here.
   vector<int>ans;
   map<int,int>mp;
   for(int i=0;i<n;i++){
       mp[arr[i]]++;
          }
    priority_queue<pair<int,int>>q;
    for(auto i:mp){
        q.push({i.second,i.first});
    }
    for(int i=0;i<k;i++){
        ans.push_back(q.top().second);
        q.pop();
    }
    sort(ans.begin(),ans.end());
    return ans;
}
Q75
/*
    Your Trie object will be instantiated and called as such:
    Trie* obj = new Trie();
    obj->insert(word);
    bool check2 = obj->search(word);
    bool check3 = obj->startsWith(prefix);
 */
struct Node{
    Node *links[26];
    bool flag=false;
    bool containskey(char ch){
        return links[ch-'a']!=NULL;
    }
    void put(char ch,Node* node){
        links[ch-'a']=node;

    }
    Node* get(char ch){
        return links[ch-'a'];
    }
    bool setEnd(){
        flag=true;
    }
    bool isEnd()
    {
        return flag;
    }
};

class Trie {
    private: Node* root;

public:

    /** Initialize your data structure here. */
    Trie() {

        root=new Node();

    }

    /** Inserts a word into the trie. */
    void insert(string word) {
        Node* node=root;
        for(int i=0;i<word.size();i++)
        {
            if(!node->containskey(word[i]))
            {
                node->put(word[i],new Node());

            }
            node=node->get(word[i]);

        }
        node->setEnd();


    }

    /** Returns if the word is in the trie. */
    bool search(string word) {
        Node *node=root;
        for(int i=0;i<word.size();i++)
        {
            if(!node->containskey(word[i])){
                return false;

            }
            node=node->get(word[i]);
        }
        return node->isEnd();

    }

    /** Returns if there is any word in the trie that starts with the given prefix. */
    bool startsWith(string prefix) {
        Node*node=root;
        for(int i=0;i<prefix.size();i++)
        {
             if(!node->containskey(prefix[i])){
                return false;

            }
            node=node->get(prefix[i]);

        }
        return true;

    }
};
Q76
#include <bits/stdc++.h>

struct Node {
  Node *links[26];
  int cntEndsWith = 0, cntPrefix = 0;

  void put(char ch, Node *newNode) { links[ch - 'a'] = newNode; }

  Node *get(char ch) { return links[ch - 'a']; }

  bool containsKey(char ch) { return links[ch - 'a'] != NULL; }

  void increaseEnd() { cntEndsWith++; }

  void increasePrefix() { cntPrefix++; }

  void decreaseEnd() { cntEndsWith--; }

  void decreasePrefix() { cntPrefix--; }

  int getEnd() { return cntEndsWith; }

  int getPrefixes() { return cntPrefix; }
};

class Trie {
  Node *root;

public:
  Trie() { root = new Node(); }

  void insert(string &word) {
    Node *node = root;
    for (auto c : word) {
      if (!node->containsKey(c))
        node->put(c, new Node());

      node = node->get(c);
      node->increasePrefix();
    }

    node->increaseEnd();
  }

  int countWordsEqualTo(string &word) {
    Node *node = root;
    for (auto c : word) {
      if (!node->containsKey(c))
        return 0;
      else
        node = node->get(c);
    }
    return node->getEnd();
  }

  int countWordsStartingWith(string &word) {
    Node *node = root;
    for (auto c : word) {
      if (!node->containsKey(c))
        return 0;
      else
        node = node->get(c);
    }
    return node->getPrefixes();
  }

  void erase(string &word) {
    Node *node = root;
    for (auto c : word) {
      if (!node->containsKey(c))
        return;

      node = node->get(c);
      node->decreasePrefix();
    }
    
    node->decreaseEnd();
  }
};
Q77
#include <bits/stdc++.h> 
class TierNode{
    public:
     TierNode* child[26];
    bool isEnd;
};
void insert(string &w,TierNode* node){
    TierNode* curr = node;
    for(auto c: w){
        if(curr->child[c-'a'] == NULL)curr->child[c-'a'] = new TierNode();
        curr = curr->child[c-'a'];
    }
    curr->isEnd = true;
}

bool isCompStr(string &w,TierNode* node){
    TierNode* curr = node;
    for(auto c: w){
        if(curr->child[c-'a'] == NULL)return false;
        curr = curr->child[c-'a'];
        if(curr->isEnd == false)return false;
    }

    return true;
}

string completeString(int n, vector<string> &a){
    // Write your code here.
    TierNode* node = new TierNode();

    for(auto w: a)insert(w,node);

    string ans = "";
    for(auto w: a){
        if(isCompStr(w,node)){
          if (ans.length() <= w.length()) {
            ans = ans.length() == w.length() ? min(ans, w) : w;
          }
        }
    }

    return ans.length() == 0 ? "None" : ans;
}
Q78
// #include <bits/stdc++.h> 
// int distinctSubstring(string &str) {
//     //  Write your code here.
//     set<string> result ;

 

//     for (int i = 0; i <= str.length(); i++)

//     {

//         for (int j = 1; j <= str.length()-i; j++)

//         {

 

//             result.insert(str.substr(i, j));

//         }

//     }

//     return result.size();
// }
#include <bits/stdc++.h> 

 

class Node{

    public:

    Node* links[26];

};

 

void insert(Node* root,string &s,int &cnt)

{

    int n=s.length();

    Node* cur=root;

    for(int i=0;i<n;i++)

    {

        if(cur->links[s[i]-'a']==NULL)

        {

            cnt++;

            cur->links[s[i]-'a']=new Node();

        }

        cur=cur->links[s[i]-'a'];

    }

}

 

int distinctSubstring(string &word) {

    //  Write your code here.

    int n=word.length();

    Node* root=new Node();

    int cnt=0;

    for(int i=0;i<n;i++)

    {

        string s;

        for(int j=i;j<n;j++)

        {

            s+=word[j];

            insert(root,s,cnt);

        }

    }

    return cnt;

}

 
Q79
#include <bits/stdc++.h> 
vector<vector<int>> pwset(vector<int>v)
{
    //Write your code here
    int n=v.size();

vector<vector<int>>ans;

for(int num=0;num<(1<<n);num++){

vector<int>temp;

for(int i=0;i<n;i++){

if(num&(1<<i)){

temp.push_back(v[i]);

}

}

if(temp.size()>0){

ans.push_back(temp);

}

}

sort(ans.begin(),ans.end());

return ans;
}
Q80
#include <bits/stdc++.h> 
/*int maximumXor(vector<int> A)
{
    // Write your code here.
    int ans=INT_MIN;
    if(A.size()<2)return 0;
    for(int i=0;i<A.size();i++){
        for(int j=i+1;j<A.size();j++)
        {
            int maxi=A[i]^A[j];
            ans=max(ans,maxi);
        }

    }
    return ans;

}*/
struct Node {

  

    Node* child[2];

    bool contains(int bit){

        return child[bit]!=NULL;

    }

    Node* get(int bit){

        return child[bit];


 

    }

    Node*put(int bit,Node* node){

        child[bit]=node;

    }

};


 

class Trie {

    public:

    Node* root;

    Trie() {

        root=new Node();

    }

    void insert(int num){

        Node* node=root;

        for(int i=31;i>=0;i--){

            int bit=(num>>i)&1;

            if(!node->contains(bit)){

                node->put(bit,new Node());

            }

            node=node->get(bit);

        }

    }

    int getmax(int num){

        Node* node=root;

        int maxnum=0;

        for(int i=31;i>=0;i--){

            int bit=(num>>i)&1;

            if(node->contains(1-bit)){

                maxnum=(1<<i)|maxnum;

                node=node->get(1-bit);               


 

            }else{

                node=node->get(bit);

            }

        }

        return maxnum;

    }

};




 

 int maximumXor(vector<int> A) {

  // Write your code here.

  Trie trie;

  for(auto it:A){

      trie.insert(it);

  }

  int maxi=0;

  for(auto it:A){

      maxi=max(maxi,trie.getmax(it));

  }

  return maxi;

}
Q81
#include<bits/stdc++.h>

 

   struct Node{       

        Node* links[2];        

        bool containsKey(int bit){

            return links[bit] != NULL;        

            }        

        void put(int bit, Node* node){            

            links[bit] = node;                    

            }        

            Node* get(int bit){

                            return links[bit];        

                            }    

                            };        

    class Trie{    

        private:        

        Node* root;    

        public:        

        Trie(){            

            root = new Node();        

            }        

            void insert(int num){            

                Node* node = root;            

                for ( int i = 30; i>=0; i-- ){                

                    int bit = ( num >> i ) & 1;                

                    if ( !node->containsKey(bit) ){                    

                        node->put(bit,new Node());                

                        }                

                        node = node->get(bit);            

                        }        

                        }        

                        int max_XOR(int num){            

                            Node* node = root;            

                            int ans = 0;            

                            for ( int i = 30; i>=0; i-- ){                

                                int bit = ( num >> i ) & 1;                

                                if ( node->containsKey(!bit) ){                    

                                    ans = ans ^ (1 << i);                    

                                    node = node->get(!bit);                

                                    } else {                    

                                        node = node->get(bit);                

                                        }            

                                        }            

                                        return ans;        

                                        }    

                                        };        

                                        static bool cmp( vector<int> a, vector<int> b ){        

                                            return a[1] < b[1];    

                                            }

 

   vector<int> maxXorQueries(vector<int> &arr, vector<vector<int>> &queries){             

       int n = queries.size(), m = arr.size(), j = 0;        

       Trie node;        

       vector<int> ans(n,-1);        

       for ( int i = 0; i<n; i++ ){            

           queries[i].push_back(i);        

           }        

           sort(arr.begin(),arr.end());        

           sort(queries.begin(),queries.end(),cmp);        

           for ( int i = 0; i<n; i++ ){            

               while ( j < m && arr[j] <= queries[i][1] ){                

                   node.insert(arr[j++]);            

                   }            

                   if ( j > 0 )                

                   ans[ queries[i][2] ] = node.max_XOR(queries[i][0]);        

                   }        

                   return ans;    

                   }
Q82
#include <bits/stdc++.h> 
// Stack class.
class Stack {
    private:
    int*arr;
    int to;
    int max_size;
    
public:
    
    Stack(int capacity) {
        // Write your code here.
        arr=new int[capacity];
        to = -1;
        max_size=capacity;
        
    }

    void push(int num) {
        // Write your code here.
        if(to+1!=max_size)
               arr[to+1]=num;
               to++;

    }

    int pop() {
        // Write your code here.
        if(to!=-1){
            
            return arr[to--];
        }
        return -1;
    }
    
    int top() {
        // Write your code here.
        if(to!=-1){
            return arr[to];
        }
        return -1;

    }
    
    int isEmpty() {
        // Write your code here.
        if(to==-1)return 1;
        return 0;
    }
    
    int isFull() {
        // Write your code here.
        if(to!=max_size)return 0;
        return 1;
    }
    
};
Q83
#include <bits/stdc++.h> 
class Queue {
    private:
    int* arr;
    int qfront;
    int rear;
    int size;


public:
    Queue() {
        // Implement the Constructor
        size=1000;
        arr=new int[1000];
        qfront=0;
        rear=0;
    }

    /*----------------- Public Functions of Queue -----------------*/

    bool isEmpty() {
        // Implement the isEmpty() function
        if(qfront==rear)return true;
        return false;

    }

    void enqueue(int data) {
        // Implement the enqueue() function
        if(rear==size)return;
        arr[rear]=data;
        rear++;
    }

    int dequeue() {
        // Implement the dequeue() function
        if(qfront==rear)return -1;
        int ans=arr[qfront];
        arr[qfront]=-1;
        
        qfront++;
        if(qfront==rear)
        {
            qfront=0;
            rear=0;

        }
        return ans;
    }

    int front() {
        // Implement the front() function
        if(qfront==rear){
            return -1;
        }
        return arr[qfront];
    }
};
Q84
#include <bits/stdc++.h> 
class Stack {
	// Define the data members.
    queue<int>q1,q2;
    int size;


   public:
    Stack() {
        // Implement the Constructor.
        size=0;
    }

    /*----------------- Public Functions of Stack -----------------*/

    int getSize() {
        // Implement the getSize() function.
        return size;

    }

    bool isEmpty() {
        // Implement the isEmpty() function.
        if(size==0)return true;
        return false;

    }

    void push(int element) {
        // Implement the push() function.
        q2.push(element);
        while(!q1.empty())
        {
            q2.push(q1.front());
            q1.pop();
        }
        swap(q1,q2);
        size++;
    }

    int pop() {
        // Implement the pop() function.

        if (!q1.empty()) {
          int val = q1.front();
          q1.pop();
          size--;
          return val;
        }
        return -1;

        
        

        
    }

    int top() {
        // Implement the top() function.
       if(!q1.empty())return q1.front();
       return -1;
    }
};
Q85
#include <stack>

class Queue {
private:
    stack<int> first;
    stack<int> second;
    
public:
    Queue() {
        // Initialize your data structure here.
    }

    void enQueue(int val) {
        first.push(val);
    }

    int deQueue() {
        if(!second.empty()){
            int data = second.top();
            second.pop();
            return data;
        }
        else{
            if(first.empty()){
                return -1;
            }
            else{
                while(!first.empty()){
                    second.push(first.top());
                    first.pop();
                }
                int data = second.top();
                second.pop();
                return data;
            }
        }
    }

    int peek() {
        if(!second.empty()){
            return second.top();;
        }
        else{
            if(first.empty()){
                return -1;
            }
            else{
                while(!first.empty()){
                    second.push(first.top());
                    first.pop();
                }
                return second.top();;
            }
        }
    }

    bool isEmpty() {
        return (first.empty() && second.empty());
    }
};
Q86
bool match(char s1, char s2) {

  return (s1 == '(' && s2 == ')') || (s1 == '[' && s2 == ']') || (s1 == '{' && s2 == '}');

}

bool isValidParenthesis(string expression)

{

    // Write your code here.

    stack<int>s;

    for(int i=0;i<expression.length();i++)

    {

        if(expression[i]=='(' || expression[i]=='{'|| expression[i]=='[')

        s.push(expression[i]);

        else if(!s.empty() && match(s.top(), expression[i]))

        s.pop();

        else

        return false;

  }

 

  return s.empty();

 

 }

 Q87
#include <bits/stdc++.h> 
#include<stack>
vector<int> nextGreater(vector<int> &arr, int n) {
    // Write your code here
   stack<int>s;
   s.push(-1);
   for(int i=n-1;i>=0;i--){
       int curr=arr[i];
       while(!s.empty()&&s.top()<=curr){
           s.pop();
       }
       if(s.empty()){
           arr[i]=-1;
       }
       else{
           arr[i]=s.top();
       }
       s.push(curr);

   }
   return arr;
    
  


}
Q88
#include <bits/stdc++.h> 
void sortedInsert(stack<int> &stack, int x){
	// Base case
	if(stack.empty() || (!stack.empty() && stack.top() < x)){
		stack.push(x);
		return ;
	}
	int num = stack.top();
    stack.pop(); 
	sortedInsert(stack, x);
	stack.push(num);
}

void sortStack(stack<int> &stack)
{
	// Base case
    if(stack.empty()){
        return;
    }
    int num = stack.top();
    stack.pop();
    sortStack(stack);

    sortedInsert(stack, num);
}
Q89
#include<stack>
vector<int> nextSmallerElement(vector<int> &arr, int n)
{
    // Write your code here.
    stack<int>s;
    s.push(-1);
    for(int i=n-1;i>=0;i--)
    {
        int curr=arr[i];
        while(s.top()>=curr){
            s.pop();

        }
        
            arr[i]=s.top();
        
        s.push(curr);
    }
    return arr;

}
Q90
#include<bits/stdc++.h>

 

class LRUCache

{

public:

class node{

 public:

 int key;

 int data;

 node* prev;

 node* next;

 node(int keyy,int dataa){

     key=keyy;

     data=dataa;

 }

 

};

node* head=new node(-1,-1);

node* tail=new node(-1,-1);

int cap;

 

unordered_map<int,node*> m;

    LRUCache(int capacity)

    {

        cap=capacity;

        head->next=tail;

        tail->prev=head;

        // Write your code here

    }

void deletee(node* temp){

    node* p=temp->prev;

    node* n=temp->next;

    p->next=n;

    n->prev=p;

 

}

void add(node* temp){

  node* p=head->next;

  head->next=temp;

  temp->next=p;

  p->prev=temp;

  temp->prev=head;

 

}

    int get(int key)

    {  if(m.find(key)!=m.end()){

        node* temp=m[key];

        int vl=temp->data;

      m.erase(key);

        deletee(temp);

        add(temp);

        m[key]=head->next;

        return vl;

        

 

    }

  return -1;

        // Write your code here

    }

 

    void put(int key, int value)

    {    if(m.find(key)!=m.end()){

        node *temp=m[key];

        m.erase(key);

        deletee(temp);

      

    }

     if(m.size()==cap){

        m.erase(tail->prev->key);

 

        deletee(tail->prev);

       

    }

    

    add(new node(key,value));

    m[key]=head->next;

 

    

 

    

        // Write your code here

    }

};

 Q91
#include<bits/stdc++.h>
struct Node {
    int key, value, cnt;
    Node *next; 
    Node *prev;
    Node(int _key, int _value) {
        key = _key;
        value = _value; 
        cnt = 1; 
    }
}; 
struct List {
    int size; 
    Node *head; 
    Node *tail; 
    List() {
        head = new Node(0, 0); 
        tail = new Node(0,0); 
        head->next = tail;
        tail->prev = head; 
        size = 0;
    }
    
    void addFront(Node *node) {
        Node* temp = head->next;
        node->next = temp;
        node->prev = head;
        head->next = node;
        temp->prev = node;
        size++; 
    }
    
    void removeNode(Node* delnode) {
        Node* delprev = delnode->prev;
        Node* delnext = delnode->next;
        delprev->next = delnext;
        delnext->prev = delprev;
        size--; 
    }
    
    
    
};

class LFUCache
{
    map<int, Node*> keyNode; 
    map<int, List*> freqListMap; 
    int maxSizeCache;
    int minFreq; 
    int curSize;

public:

    

    LFUCache(int capacity)
    {
        // Write your code here.
        maxSizeCache = capacity; 
        minFreq = 0;
        curSize = 0; 
    }

     void updateFreqListMap(Node *node) {
        keyNode.erase(node->key); 
        freqListMap[node->cnt]->removeNode(node); 
        if(node->cnt == minFreq && freqListMap[node->cnt]->size == 0) {
            minFreq++; 
        }
        
        List* nextHigherFreqList = new List();
        if(freqListMap.find(node->cnt + 1) != freqListMap.end()) {
            nextHigherFreqList = freqListMap[node->cnt + 1];
        } 
        node->cnt += 1; 
        nextHigherFreqList->addFront(node); 
        freqListMap[node->cnt] = nextHigherFreqList; 
        keyNode[node->key] = node;
    }

    int get(int key)
    {
        // Write your code here.
        if(keyNode.find(key) != keyNode.end()) {
            Node* node = keyNode[key]; 
            int val = node->value; 
            updateFreqListMap(node); 
            return val; 
        }
        return -1; 
    }

    void put(int key, int value)
    {
        // Write your code here.
        if (maxSizeCache == 0) {
            return;
        }
        if(keyNode.find(key) != keyNode.end()) {
            Node* node = keyNode[key]; 
            node->value = value; 
            updateFreqListMap(node); 
        }
        else {
            if(curSize == maxSizeCache) {
                List* list = freqListMap[minFreq]; 
                keyNode.erase(list->tail->prev->key); 
                freqListMap[minFreq]->removeNode(list->tail->prev);
                curSize--; 
            }
            curSize++; 
            // new value has to be added who is not there previously 
            minFreq = 1; 
            List* listFreq = new List(); 
            if(freqListMap.find(minFreq) != freqListMap.end()) {
                listFreq = freqListMap[minFreq]; 
            }
            Node* node = new Node(key, value); 
            listFreq->addFront(node);
            keyNode[key] = node; 
            freqListMap[minFreq] = listFreq; 
        }
    }
};
Q92
 #include<bits/stdc++.h>
 int largestRectangle(vector < int > & heights) {
   // Write your code here.
   int n=heights.size();
   vector<int> rightSmaller(n,0),leftSmaller(n,0);
   stack<int> st;

   // right smallers
   for(int i=n-1;i>=0;i--){
     if(st.empty()){
       rightSmaller[i]=n-1;
       st.push(i);
     }
     else if(heights[st.top()]<heights[i]){
       rightSmaller[i]=st.top()-1;
       st.push(i);
     }
     else {
       while(!st.empty() && heights[st.top()]>=heights[i]) st.pop();

       if(st.empty()){
         rightSmaller[i]=n-1;
         st.push(i);
       }
       else {
         rightSmaller[i]=st.top()-1;
         st.push(i);
       }
     }
   }

  
   // empty stack so that we can use it again
   while(!st.empty()) st.pop();


   // left smallers
   for(int i=0;i<n;i++){
     if(st.empty()){
       leftSmaller[i]=0;
       st.push(i);
     }
     else if(heights[st.top()]<heights[i]){
       leftSmaller[i]=st.top()+1;
       st.push(i);
     }
     else {
       while(!st.empty() && heights[st.top()]>=heights[i]) st.pop();

       if(st.empty()){
         leftSmaller[i]=0;
         st.push(i);
       }
       else {
         leftSmaller[i]=st.top()+1;
         st.push(i);
       }
     }
   }

  int maxi=0;
  for(int i=0;i<n;i++){
    int area=heights[i]*(rightSmaller[i]-leftSmaller[i]+1);
    maxi=max(maxi,area);
  }
  return maxi;
 }
Q93
#include <bits/stdc++.h> 
vector<int> slidingWindowMaximum(vector<int> &nums, int &k)
{
    //    Write your code here.
    deque < int > dq;
  vector < int > ans;
  for (int i = 0; i < nums.size(); i++) {
    if (!dq.empty() && dq.front() == i - k) dq.pop_front();

    while (!dq.empty() && nums[dq.back()] < nums[i])
      dq.pop_back();

    dq.push_back(i);
    if (i >= k - 1) ans.push_back(nums[dq.front()]);
  }
  return ans;
}
Q94
#include <bits/stdc++.h> 
// Implement class for minStack.
class minStack
{
	// Write your code here.
	stack<pair<int,int>>s;
	
	public:
		
		// Constructor
		minStack() 
		{ 
			// Write your code here.
			
		}
		
		// Function to add another element equal to num at the top of stack.
		void push(int num)
		{
			// Write your code here.
			if(s.empty()){
				s.push({num,num});

			}else if(s.top().second<num){
				s.push({num,s.top().second});
			}
			else{
				s.push({num,num});
			}

		}
		
		// Function to remove the top element of the stack.
		int pop()
		{
			// Write your code here.
			if(s.empty())return -1;
			auto it=s.top();
			s.pop();
			return it.first;
		}
		
		// Function to return the top element of stack if it is present. Otherwise return -1.
		int top()
		{
			// Write your code here.
			return s.empty()?-1:s.top().first;
		}
		
		// Function to return minimum element of stack if it is present. Otherwise return -1.
		int getMin()
		{
			// Write your code here.
			return s.empty()?-1:s.top().second;

		}
};
Q95
#include<bits/stdc++.h>

int minTimeToRot(vector<vector<int>>& grid, int n, int m)

{

    // Write your code here. 

    //{{r,c},tm}

    queue<pair<pair<int,int>,int>>  q;

    int visited[n][m];

   

    for(int i=0; i<n; i++){

        for(int j=0; j<m; j++){

            if(grid[i][j]==2){

                q.push({{i,j},0});

                visited[i][j]=2;

            }

            else{

                visited[i][j]=0;

            }

        }

    }

    int tm=0;

    int drow[] = {-1,0,1,0};

    int dcol []= {0,1,0,-1};

    while(!q.empty()){

        int r=q.front().first.first;

        int c=q.front().first.second;

        int t=q.front().second;

        tm=max(tm,t);

        q.pop();

        for(int i=0; i<4; i++){

            int nrow=r+drow[i];

            int ncol=c+dcol[i];

            if(nrow>=0 && nrow<n && ncol>=0 && ncol<m && visited[nrow][ncol]!=2 && grid[nrow][ncol]==1){

                q.push({{nrow,ncol}, tm+1});

                visited[nrow][ncol]=2;

            }  

 

        }

 

    }

    for(int i=0; i<n; i++){

        for(int j=0; j<m; j++){

            if(visited[i][j]!=2 && grid[i][j]==1)return -1;

        }

    }

    return tm;

}
Q96
#include <bits/stdc++.h>

class StockPlanner {
private:
  stack<pair<int, int>> s;

public:
  int next(int price) {
    int day = 1;
    while (!s.empty() and price >= s.top().first) {
      day += s.top().second;
      s.pop();
    }

    s.push({price, day});
    return day;
  }
};

vector<int> findSpans(vector<int> &price) {
  vector<int> ans;
  StockPlanner s;

  for (auto p : price) {
    int span = s.next(p);
    ans.push_back(span);
  }

  return ans;
}
Q97
#include <bits/stdc++.h> 
vector<int> maxMinWindow(vector<int> a, int n) {
    // Write your code here.
      vector<int> res(n,INT_MIN);
    
    stack<int> s;
    a.push_back(INT_MIN);
    
    for (int i = 0; i < a.size(); i++)
    {
        while(!s.empty() && a[s.top()]>=a[i]){
            int top = a[s.top()]; s.pop();
            int smal_left = s.empty()? -1 : s.top();
            int range = i - smal_left - 1;
            if(res[range-1]<top) res[range-1] = top;
        }
        s.push(i);
    }

    int max=INT_MIN;

    for(int i = res.size()-1;i>-1;i--){
        if(res[i]>max) max = res[i];
        res[i] = max;
    }
    
    return res;
}
Q98
#include <bits/stdc++.h> 
/*
	This is signature of helper function 'knows'.
	You should not implement it, or speculate about its implementation.

	bool knows(int A, int B); 
	Function 'knows(A, B)' will returns "true" if the person having
	id 'A' know the person having id 'B' in the party, "false" otherwise.
*/


class StockPlanner {
private:
  stack<pair<int, int>> s;

public:
  int next(int price) {
    int day = 1;
    while (!s.empty() and price >= s.top().first) {
      day += s.top().second;
      s.pop();
    }

    s.push({price, day});
    return day;
  }
};

vector<int> findSpans(vector<int> &price) {
  vector<int> ans;
  StockPlanner s;

  for (auto p : price) {
    int span = s.next(p);
    ans.push_back(span);
  }

  return ans;
}
Q99
#include<bits/stdc++.h>
string reverseString(string &str){
	// Write your code here.
	stack<string> s; 
	string a; 
	for(int i=0;i<str.size();i++)
	{  if(str[i]!=' '){
		a+=str[i];  
		}  


	   if(str[i]==' ' || i==str.size()-1)
	   {   if(a.size()!=0){
		    s.push(a);   
			a.clear();   
			}  
		} 
	} 
	   string t; 
    while(s.size()>0){ 
	    t+=s.top(); 
		s.pop();  
		if(s.size()!=0){ 
			t+=' ';  
		} 
	}
	 return t;
}
Q100
/*
bruteforce 
bool ispalindrome(string s){

    for(int i=0;i<s.size()/2;i++){
        if(s[i]!=s[s.size()-1-i]){
            return false;
        }

    }
    return true;
}
string longestPalinSubstring(string str)
{
    // Write your code here.
    int s=str.size(),ans=0;
    string p="";
    for(int i=0;i<s;i++){
        for(int j=i;j<s;j++){
            if(ispalindrome(str.substr(i,j-i+1))){
                if(ans<j-i+1){
                    ans=j-i+1;
                    p=str.substr(i,j-i+1);

                }

            }
        }
    }
    return p;
    
}*/
// string longestPalinSubstring(string str){
//     int n=str.size();
//     int maxlength=0;
//     string ans="";
//     vector<vector<int>>dp(n,vector<int>(n,0));
//     for(int diff=0;diff<n;diff++){
//         for(int i=0,j=i+diff;j<n;i++,j++){
//             if(i==j)dp[i][j]=1;
//             else if(diff==1){
//                 dp[i][j]=(str[i]==str[j])?2:0;
//             }
//             else{
//                 if(str[i]==str[j] && dp[i+1][j-1]>0){
//                     dp[i][j]=dp[i+1][j-1]+2;
//                 }
                
//             }
//             if(dp[i][j]){
//                 if(j-i+1>maxlength){
//                     maxlength=j-i+1;
//                     ans=str.substr(i,maxlength);
//                 }
//             }
//         }
//     }
//     return ans;



// }
string longestPalinSubstring(string str)

{

    // Write your code here.

    int n=str.length();

    int l,r;

    int start=0;

    int end=1;

 

    for(int i=1;i<n;i++)

    {

        //even substring

        l=i-1;

        r=i;

 

        while(l>=0 && r<n && str[l]==str[r])

        {

            if(r-l+1 > end)

            {

                start=l;

                end=r-l+1;

                

            }

            l--;

            r++;

        }

 

        // odd substring

        l=i-1;

        r=i+1;

 

        while(l>=0 && r<n && str[l]==str[r])

        {

            if(r-l+1 > end)

            {

                start=l;

                end=r-l+1;

                

            }

            l--;

            r++;

        }

    }

    return str.substr(start,end);

}
Q101
int romanToInt(string s) {
     int len=s.size();

    int sum=0;

    int i=0;

    while(i<len){

if(s[i]=='I' and s[i+1]=='V'){sum+=4;i=i+2;continue;}

if(s[i]=='I' and s[i+1]=='X'){sum+=9;i=i+2;continue;}

if(s[i]=='X' and s[i+1]=='L'){sum+=40;i=i+2;continue;}

if(s[i]=='X' and s[i+1]=='C'){sum+=90;i=i+2;continue;}

if(s[i]=='C' and s[i+1]=='D'){sum+=400;i=i+2;continue;}

if(s[i]=='C' and s[i+1]=='M'){sum+=900;i=i+2;continue;}

      if (s[i] == 'I') {

        sum += 1;

        i = i + 1;continue;

      }

        if(s[i]=='V'){

            sum+=5;

            i=i+1;continue;

        }

        if(s[i]=='X'){

            sum+=10;

            i=i+1;continue;

        }

        if(s[i]=='L'){

            sum+=50;

            i=i+1;continue;

        }

        if(s[i]=='C'){

            sum+=100;

            i=i+1;continue;

        }

        if(s[i]=='D'){

            sum+=500;

            i=i+1;continue;

        }

        if(s[i]=='M'){

            sum+=1000;

            i=i+1;continue;

        }

        

    }

    return sum;
}
Q102
#include <bits/stdc++.h> 
int atoi(string str) {
    // Write your code here.
    string a="";
    for(int i=0;i<str.size();i++)
    {
        if(str[i]<65 && str[i]!='-'){
            a+=str[i];
        }


    }
    if(str[0]=='-'){
        return -stoi(a);
    }
    return stoi(a);
    
}
Q103
#include<bits/stdc++.h>
string longestCommonPrefix(vector<string> &arr, int n)
{
    // Write your code here
    string ans="";
    sort(arr.begin(),arr.end());
    string s=arr[0],e=arr[n-1];
    for(int i=0;i<s.size();i++){
        if(s[i]!=e[i]){
            break;
        }
        ans+=s[i];
    }
    
    return ans;
}

Q104
vector<int> stringMatch(string p, string s) {
	// Write your code here.
	 vector<int>ans;
            int ssize=s.length(),psize=p.length();
            for(int i=0;i<-ssize+psize+1;i++)
            {
                if(p.substr(i,ssize)==s){
                    ans.push_back(i+1);
                }
            }
           
            return ans;
}

Q105
int zAlgorithm(string s, string p, int n, int m)
{
	// Write your code here
	int count=0;
	for(int i=0;i<n-m+1;i++)
	{
		if(s.substr(i,m)==p){
			count++;
		}
	}
	return count;
}
Q106
#include <bits/stdc++.h> 
bool findPattern(string p, string s)
{
    // Write your code here.
    int ssize=s.size(),psize=p.size();
    for(int i=0;i<ssize-psize+1;i++){
        if(s.substr(i,psize)==p){
            return true;
        }
    }
    return false;
}
Q107

// bool ispalindrome(string str)
// {
// 	int l=0,r=str.size()-1;
// 	while(l<r){
// 		if(str[l]!=str[r]){
// 			return false;
// 		}
// 		l++;
// 		r--;

// 	}
// 	return true;
// }
// int minCharsforPalindrome(string str) {
// 	// Write your code here.
// 	int l=0,r=str.size()-1,count=0;
// 	while(l<r){
// 		if(str[l]==str[r]&& ispalindrome(str.substr(l,r-l+1))==true){
			
// 				break;
			
			
// 		}
// 		else{
// 			r--;
// 			count++;
// 		}

// 	}
// 	return count;
	
	
// }
#include<bits/stdc++.h>
int minCharsforPalindrome(string str) {
	int n = str.size();
	int i = 0, j = n - 1, count = 0, tempJ = j;
	while(i < j) {
		if(str[i] == str[j])
			i++, j--;
		else {
			count++;
			i = 0, tempJ--;
			j = tempJ;
		}
	}	
	return count;
}
Q108
#include <bits/stdc++.h> 
bool areAnagram(string &str1, string &str2){
    // Write your code here.
    sort(str1.begin(),str1.end());
    sort(str2.begin(),str2.end());
    for(int i=0;i<str1.size();i++)
    {
        if(str1[i]!=str2[i])
        {
            return false;
        }
        

    }
    return true;
    
}
Q109
#include <bits/stdc++.h> 
string writeAsYouSpeak(int n) 
{
	// Write your code here.
	string s="1";

    for(int i=0;i<n-1;i++)

    {

        string a;

        for(int j=0;j<s.length();)

        {

            int cnt=0;

            int k=j;

            while(j<s.length() && s[j]==s[k])

            {

                cnt++;

                k++;

            }

            a+=to_string(cnt)+s[j];

            j=k;

        }

        s=a;

    }   

    return s;

}
Q110
#include <bits/stdc++.h> 
int compareVersions(string a, string b) 
{
    // Write your code here
    int i=0;

    int j=0;

    while(i<a.size()||j<b.size()){

 long x=0;

 long y=0;

 while(i<a.size()&&a[i]!='.')x=x*10+(a[i++]-'0');

 while(j<b.size()&&b[j]!='.')y=y*10+(b[j++]-'0');

 if(x>y)return 1;

 else if(x<y)return -1;

 i++;

 j++;

 

    }

    return 0;
}
Q111
#include <bits/stdc++.h> 
/*
    Following is Binary Tree Node structure:
    class TreeNode
    {
    public:
        int data;
        TreeNode *left, *right;
        TreeNode() : data(0), left(NULL), right(NULL) {}
        TreeNode(int x) : data(x), left(NULL), right(NULL) {}
        TreeNode(int x, TreeNode *left, TreeNode *right) : data(x), left(left), right(right) {}
    };
*/
void inorder(TreeNode* root,vector<int>&ans){
    if(root==NULL)return;
    inorder(root->left,ans);
    ans.push_back(root->data);
    inorder(root->right,ans);
}
vector<int> getInOrderTraversal(TreeNode *root)
{
    // Write your code here.
    vector<int>ans;
    inorder(root,ans);
    return ans;
}
Q112
#include <bits/stdc++.h> 
/*
    Following is Binary Tree Node structure:
    class TreeNode
    {
    public:
        int data;
        TreeNode *left, *right;
        TreeNode() : data(0), left(NULL), right(NULL) {}
        TreeNode(int x) : data(x), left(NULL), right(NULL) {}
        TreeNode(int x, TreeNode *left, TreeNode *right) : data(x), left(left), right(right) {}
    };
*/
void preorder(TreeNode* root,vector<int>&ans){
    if(root==NULL)return;
    ans.push_back(root->data);
    preorder(root->left,ans);
    preorder(root->right,ans);
}
vector<int> getPreOrderTraversal(TreeNode *root)
{
    // Write your code here.
    vector<int>ans;
    preorder(root,ans);
    return ans;
}
Q113
#include <bits/stdc++.h> 
/*
    Following is Binary Tree Node structure:
    class TreeNode

    {
    public:
        int data;
        TreeNode *left, *right;
        TreeNode() : data(0), left(NULL), right(NULL) {}
        TreeNode(int x) : data(x), left(NULL), right(NULL) {}
        TreeNode(int x, TreeNode *left, TreeNode *right) : data(x), left(left), right(right) {}
    };
*/
void postorder(TreeNode* root,vector<int>&ans){
    if(root==NULL)return ;
    postorder(root->left,ans);
    postorder(root->right,ans);
    ans.push_back(root->data);
}

vector<int> getPostOrderTraversal(TreeNode *root)
{
    // Write your code here.
    vector<int>ans;
    postorder(root,ans);
    return ans;
}
Q114
#include <bits/stdc++.h> 
/************************************************************

    Following is the TreeNode class structure

    template <typename T>
    class TreeNode {
       public:
        T data;
        TreeNode<T> *left;
        TreeNode<T> *right;

        TreeNode(T data) {
            this->data = data;
            left = NULL;
            right = NULL;
        }
    };

************************************************************/
void leftView(TreeNode<int> *root,vector<int>& ans,int level){
    if(root==NULL)return;
    
    if(level==ans.size()){
        ans.push_back(root->data);
    }
    if(!root->left && !root->right)return;
    leftView(root->left,ans,level+1);
    leftView(root->right,ans,level+1);
}

vector<int> getLeftView(TreeNode<int> *root)
{
    //    Write your code here
    vector<int>ans;
    leftView(root,ans,0);
    return ans;
   


}
Q115
#include <bits/stdc++.h> 
/*************************************************************
 
    Following is the Binary Tree node structure.

    class BinaryTreeNode 
    {
    public : 
        T data;
        BinaryTreeNode<T> *left;
        BinaryTreeNode<T> *right;

        BinaryTreeNode(T data) {
            this -> data = data;
            left = NULL;
            right = NULL;
        }
    };

*************************************************************/

vector<int> bottomView(BinaryTreeNode<int> * root){

    // Write your code here.
    vector<int>ans;
    if(root==NULL)return ans;
    map<int,int>mpp;
    queue<pair<BinaryTreeNode<int>*,int>>q;
    q.push({root,0});
    while(!q.empty()){
        auto it=q.front();
        q.pop();
        BinaryTreeNode<int>* node=it.first;
        int line=it.second;
        mpp[line]=node->data;
        if(node->left){
            q.push({node->left,line-1});
        }
        if(node->right){
            q.push({node->right,line+1});
        }


    }
    for(auto it:mpp)
    {
        ans.push_back(it.second);
    }
    return ans;
    
    
}

Q116
#include <bits/stdc++.h> 
/************************************************************

    Following is the TreeNode class structure:

    template <typename T>
    class TreeNode {
       public:
        T val;
        TreeNode<T> *left;
        TreeNode<T> *right;

        TreeNode(T val) {
            this->val = val;
            left = NULL;
            right = NULL;
        }
    };

************************************************************/

vector<int> getTopView(TreeNode<int> *root) {
    // Write your code here.


     vector<int>ans;
    if(root==NULL)return ans;
    map<int,int>mpp;
    queue<pair<TreeNode<int>*,int>>q;
    q.push({root,0});
    while(!q.empty()){
        auto it=q.front();
        q.pop();
        TreeNode<int>* node=it.first;
        int line=it.second;
        if(mpp.find(line)==mpp.end()){
          mpp[line]=node->val;
        }
        if(node->left){
            q.push({node->left,line-1});
        }
        if(node->right){
            q.push({node->right,line+1});
        }


    }
    for(auto it:mpp)
    {
        ans.push_back(it.second);
    }
    return ans;
}
Q117
#include <bits/stdc++.h> 
/************************************************************

    Following is the Binary Tree node structure:

    class BinaryTreeNode
    {
    public :
        T data;
        BinaryTreeNode<T> *left;
        BinaryTreeNode<T> *right;

        BinaryTreeNode(T data) {
            this -> data = data;
            left = NULL;
            right = NULL;
        }
    };


************************************************************/
void inorder(BinaryTreeNode<int> *root,vector<int>&ans){
    if(root==NULL)return;
    inorder(root->left,ans);
    ans.push_back(root->data);
    inorder(root->right,ans);
}
void getInOrderTraversal(BinaryTreeNode<int> *root,vector<vector<int>>&sol)
{
    // Write your code here.
    vector<int>ans;
    inorder(root,ans);
    sol.push_back(ans);
    return;

    
}
void preorder(BinaryTreeNode<int> *root,vector<int>&ans){
    if(root==NULL)return;
    ans.push_back(root->data);
    preorder(root->left,ans);
    preorder(root->right,ans);
}
void getPreOrderTraversal(BinaryTreeNode<int> *root,vector<vector<int>>&sol)
{
    // Write your code here.
    vector<int>ans;
    preorder(root,ans);
    sol.push_back(ans);
    return;
}
void postorder(BinaryTreeNode<int> *root,vector<int>&ans){
    if(root==NULL)return ;
    postorder(root->left,ans);
    postorder(root->right,ans);
    ans.push_back(root->data);
}

void getPostOrderTraversal(BinaryTreeNode<int> *root,vector<vector<int>>&sol) {
  // Write your code here.
  vector<int> ans;
  postorder(root, ans);
  sol.push_back(ans);
  return;
}

vector<vector<int>> getTreeTraversal(BinaryTreeNode<int> *root){
    // Write your code here.
    vector<vector<int>>sol;
  
    getInOrderTraversal(root,sol);
    getPreOrderTraversal(root,sol);
    getPostOrderTraversal(root,sol);
    return sol;
}
Q118
#include <bits/stdc++.h> 
/************************************************************

Following is the Binary Tree node class
    
template <typename T = int>
class TreeNode
{
public:
    T data;
    TreeNode<T> *left;
    TreeNode<T> *right;

    TreeNode(T val)
    {
        this->data = val;
        left = NULL;
        right = NULL;
    }

    ~TreeNode()
    {
        if (left != NULL)
        {
            delete left;
        }
        if (right != NULL)
        {
            delete right;
        }
    }
};

************************************************************/


vector<int> verticalOrderTraversal(TreeNode<int> *root)
{
   if(root==NULL)return {};

vector<int> v;

queue<pair<TreeNode<int>*,int>> q;

map<int,vector<int>> m;

q.push({root,0});

m[0].push_back(root->data);

while(!q.empty()){

auto it=q.front();

q.pop();

TreeNode<int> *temp=it.first;

int distance=it.second;

if(temp->left){

    q.push({temp->left,distance-1});

    m[distance-1].push_back(temp->left->data);

}

if(temp->right){

    q.push({temp->right,distance+1});

    m[distance+1].push_back(temp->right->data);

}

 

}

 

for(auto it:m){

   for(auto i:it.second){

       v.push_back(i);

   }

}

return v;
}
Q119
#include <bits/stdc++.h> 
/*   
    template <typename T = int>
	class TreeNode
	{
		public:
		T data;
		TreeNode<T> *left;
		TreeNode<T> *right;

		TreeNode(T data)
		{
			this->data = data;
			left = NULL;
			right = NULL;
		}

		~TreeNode()
		{
			if (left != NULL)
			{
		  		delete left;
			}
			if (right != NULL)
			{
			 	delete right;
			}
		}
	};
*/
bool inorderCheck(TreeNode<int> *root, int x,vector<int>& ans)
{
  if (root == NULL) {
    return false;
  }
        ans.push_back(root->data);
        if (root->data == x) {
          return true;
        }
		if(inorderCheck(root->left,x,ans)||inorderCheck(root->right,x,ans)){
			return true;
		}
		ans.pop_back();
		return false;
}


vector<int> pathInATree(TreeNode<int> *root, int x)
{
    // Write your code here.
	vector<int>ans;
	inorderCheck(root,x,ans);
	return ans;
}

Q120
#include <bits/stdc++.h> 
/************************************************************

    Following is the TreeNode class structure

    template <typename T>
    class TreeNode {
       public:
        T val;
        TreeNode<T> *left;
        TreeNode<T> *right;

        TreeNode(T val) {
            this->val = val;
            left = NULL;
            right = NULL;
        }
    };

************************************************************/

int getMaxWidth(TreeNode<int> *root)
{
    // Write your code here.
    if(root==NULL)return 0;
    int ans=0;
    queue<pair<TreeNode<int>*,int>>q;
    q.push({root,0});
    while(!q.empty()){
      int size=q.size();
      int mmin=q.front().second;
      ans=max(ans,size);
      for(int i=0;i<size;i++){
        int curr_id=q.front().second-mmin;
        TreeNode<int>*node=q.front().first;
        q.pop();
        
        if(node->left){
          q.push({node->left,curr_id*2+1});
        }
        if(node->right){
          q.push({node->right,curr_id*2+2});
        }
      }
     
      
    }
    return ans;
}
Q121
#include <bits/stdc++.h> 
/************************************************************

    Following is the BinaryTreeNode class structure

    template <typename T>
    class BinaryTreeNode {
       public:
        T val;
        BinaryTreeNode<T> *left;
        BinaryTreeNode<T> *right;

        BinaryTreeNode(T val) {
            this->val = val;
            left = NULL;
            right = NULL;
        }
    };

************************************************************/
vector<int> getLevelOrder(BinaryTreeNode<int> *root)
{
    //  Write your code here.
    vector<int>ans;
    queue<BinaryTreeNode<int>*>q;
    if(root==NULL)return ans;
    q.push(root);
    while(!q.empty()){
        BinaryTreeNode<int>*p=q.front();
        q.pop();
        ans.push_back(p->val);
        if (p->left) {
          q.push(p->left);
        }
        if(p->right){
             q.push(p->right);
        }
    }
    return ans;
}
Q122
#include <bits/stdc++.h> 
class Temp {
public:
    int height;
    int leftIndex;
    int rightIndex;

    Temp(int h, int li, int ri) {
        height = h;
        leftIndex = li;
        rightIndex = ri;
    }
};

int heightOfTheTree(vector<int>& inorder, vector<int>& levelOrder, int N){
    int maxHeight = 0;
    queue<Temp> q;

    if(N >= 1) {
        Temp temp(0, 0, N - 1);
        q.push(temp);
    }
    unordered_map<int, int> map;
    for(int i = 0;i < N; i++) {
        map[inorder[i]] = i;
    }

    for(int i = 0;i < N; i++) {
        Temp temp = q.front();
        q.pop();

        maxHeight = max(temp.height, maxHeight);

        int li = temp.leftIndex;
        int ri = temp.rightIndex;
        int rootIndex;

        rootIndex = map[levelOrder[i]];

        if(rootIndex - 1 >= li) {
            Temp leftSubTree(temp.height + 1, li, rootIndex - 1);
            q.push(leftSubTree);
        }

        if(rootIndex + 1 <= ri) {
            Temp rightSubTree(temp.height + 1, rootIndex + 1, ri);
            q.push(rightSubTree);
        }
    }

    return maxHeight;
}
Q123
/************************************************************

    Following is the TreeNode class structure

    template <typename T>
    class TreeNode {
       public:
        T data;
        TreeNode<T> *left;
        TreeNode<T> *right;

        TreeNode(T data) {
            this->data = data;
            left = NULL;
            right = NULL;
        }
    };

************************************************************/
int solve(TreeNode<int> *root,int &maxi){
  if (root == NULL) {
    return 0;
  }
  int lh=0,rh=0;
    lh=solve(root->left,maxi);
    rh=solve(root->right,maxi);
    maxi=max(maxi,lh+rh);
    return 1+max(lh,rh);
}

int diameterOfBinaryTree(TreeNode<int> *root)
{
	// Write Your Code Here.
    int maxi=0;
    solve(root,maxi);
    return maxi;
    

}


Q124
#include <bits/stdc++.h> 
/*************************************************************
 
    Following is the Binary Tree node structure

    class BinaryTreeNode 
    {
    public : 
        T data;
        BinaryTreeNode<T> *left;
        BinaryTreeNode<T> *right;

        BinaryTreeNode(T data) {
            this -> data = data;
            left = NULL;
            right = NULL;
        }
    };
    

*************************************************************/
int height(BinaryTreeNode<int>*root)
{
    if(root==NULL)return 0;
    return max(height(root->left),height(root->right))+1;
}

bool isBalancedBT(BinaryTreeNode<int>* root) {
    // Write your code here.
    if(root==NULL)return true;
    if(isBalancedBT(root->left) and isBalancedBT(root->right)){
        if(abs(height(root->left)-height(root->right))<=1)
        {
            return true;
        }
    }
    return false;
}

Q125
#include <bits/stdc++.h> 
/************************************************************

    Following is the TreeNode class structure

    template <typename T>
    class TreeNode {
       public:
        T data;
        TreeNode<T> *left;
        TreeNode<T> *right;

        TreeNode(T data) {
            this->data = data;
            left = NULL;
            right = NULL;
        }
    };

************************************************************/

int lowestCommonAncestor(TreeNode<int> *root, int x, int y)
{
	//    Write your code here
        if (root == NULL) {
          return -1;
        }
        if(root->data==x||root->data==y){
            return root->data;
        }
        int leftAns=lowestCommonAncestor(root->left,x,y);
        int rightAns=lowestCommonAncestor(root->right,x,y);
        if(leftAns!=-1 && rightAns!=-1){
            return root->data;
        }
        return max(leftAns,rightAns);
}
Q126
#include <bits/stdc++.h> 
/**********************************************************

    Following is the Binary Tree Node class structure:

    template <typename T>

    class BinaryTreeNode {
    public :
        T data;
        BinaryTreeNode<T> *left;
        BinaryTreeNode<T> *right;
		
        BinaryTreeNode(T data) {
            this -> data = data;
            left = NULL;
            right = NULL;
        }
    };

***********************************************************/

bool identicalTrees(BinaryTreeNode<int>* root1, BinaryTreeNode<int>* root2) {
    // Write your code here. 	 
    if(root1==NULL && root2==NULL){
      return true;
    }
    if (!root1 or !root2) {
      return false;
    }
    if(root1->data==root2->data){
      return (identicalTrees(root1->left,root2->left)&&identicalTrees(root1->right,root2->right));
    }
    return false;
}

Q127
#include <bits/stdc++.h> 
/*************************************************************

    Following is the Binary Tree node structure

    class BinaryTreeNode
    {
    public :
        T data;
        BinaryTreeNode<T> *left;
        BinaryTreeNode<T> *right;

        BinaryTreeNode(T data) {
            this -> data = data;
            left = NULL;
            right = NULL;
        }
    };

*************************************************************/

vector<int> zigZagTraversal(BinaryTreeNode<int> *root)
{
    // Write your code here!
    if(root==NULL)return {};
    vector<int>ans;
    queue<BinaryTreeNode<int> *>s;
    s.push(root);
    
    bool leftorright=true;
    while(!s.empty())
    {
        int size=s.size();
        vector<int>sub(size);
        for (int i = 0; i < size; i++) {

          BinaryTreeNode<int> *node = s.front();
          s.pop();
          int index=leftorright?i:size-i-1;
          sub[index]=node->data;
          
              if(node->left){
                  s.push(node->left);
                  
              }
              if(node->right){
                  s.push(node->right);
                 
              }
             
          
          }
          leftorright=!leftorright;
          for(auto i:sub){
              ans.push_back(i);
          }


        
    }
    return ans;
}

Q128
#include <bits/stdc++.h> 
/************************************************************

    Following is the Binary Tree node structure:
    
    template <typename T>
    class TreeNode {
        public :
        T data;
        TreeNode<T> *left;
        TreeNode<T> *right;

        TreeNode(T data) {
            this -> data = data;
            left = NULL;
            right = NULL;
        }

        ~TreeNode() {
            if(left)
                delete left;
            if(right)
                delete right;
        }
    };

************************************************************/
bool isleaf(TreeNode<int>*root){
    return (!root->left and !root->right);
}
void leftview(TreeNode<int>*root,vector<int>&ans){
    TreeNode<int>*cur=root->left;
    while(cur){
        if(!isleaf(cur))ans.push_back(cur->data);
        if(cur->left){
            cur=cur->left;

        }
        else{
            cur=cur->right;
        }
    }

}
void bottomview(TreeNode<int>*root,vector<int>&ans){
     if (isleaf(root)) {
    ans.push_back(root -> data);
    return;
  }
  if (root -> left) bottomview(root -> left, ans);
  if (root -> right) bottomview(root -> right, ans);
}
void rightrevview(TreeNode<int>*root,vector<int>&ans){
     TreeNode<int>*cur=root->right;
     vector<int>temp;
     while(cur){
         if(!isleaf(cur))temp.push_back(cur->data);
         if(cur->right){
             cur=cur->right;
         }
         else{
             cur=cur->left;
         }
     }
     for(int i=temp.size()-1;i>=0;i--){
         ans.push_back(temp[i]);
     }

}

vector<int> traverseBoundary(TreeNode<int>* root){
    // Write your code here.
    vector<int>ans;
    if(!root)return ans;
    ans.push_back(root->data);
    if(isleaf(root))return ans;
    leftview(root,ans);
    bottomview(root,ans);
    rightrevview(root,ans);
    return ans;



}
Q129
#include <bits/stdc++.h> 
/************************************************************

    Following is the Tree node structure
	
	template <typename T>
    class TreeNode 
    {
        public : 
        T val;
        TreeNode<T> *left;
        TreeNode<T> *right;

        TreeNode(T val) 
        {
            this -> val = val;
            left = NULL;
            right = NULL;
        }
    };

************************************************************/
long long int solve(TreeNode<int>*root,long long int& ans){
    if(root==NULL ){
        return 0;
    }
    long long int left=solve(root->left,ans);
    long long int right=solve(root->right,ans);
    ans=max(ans,root->val+left+right);
    return root->val+max(left,right);



   

}

long long int findMaxSumPath(TreeNode<int> *root)
{
    // Write your code here.
    if(root==NULL or root->left==NULL or root->right==NULL)return -1;
    long long int ans=0;
    solve(root,ans);
    return ans;
    

}
Q130
#include <bits/stdc++.h> 
/************************************************************

    Following is the TreeNode class structure

    template <typename T>
    class TreeNode {
       public:
        T data;
        TreeNode<T> *left;
        TreeNode<T> *right;

        TreeNode(T data) {
            this->data = data;
            left = NULL;
            right = NULL;
        }
    };

************************************************************/
#include <unordered_map>
TreeNode<int>*build(vector<int> &inorder,int instart,int inend,vector<int> &preorder,int prestart,int preend,unordered_map<int,int>&mp)
{
  if(instart > inend || prestart > preend) {
    return NULL;
  }
    TreeNode<int>*root=new TreeNode<int>(preorder[prestart]);
    int inroot=mp[root->data];
    int numsleft=inroot-instart;
    root->left=build(inorder,instart,inroot-1,preorder,prestart+1,prestart+numsleft,mp);
    root->right=build(inorder,inroot+1,inend,preorder,prestart+numsleft+1,preend,mp);
    return root;

}

TreeNode<int> *buildBinaryTree( vector<int> &inorder,vector<int> &preorder)
{
	//    Write your code here
    unordered_map<int,int>mp;
    int n=inorder.size();
    for(int i=0;i<n;i++)
    {
        mp[inorder[i]]=i;
    }
    return build(inorder,0,n-1,preorder,0,n-1,mp);
    
}

Q131
/************************************************************
   
   Following is the TreeNode class structure
   
   class TreeNode<T>
   { 
   public:
        T data; 
        TreeNode<T> *left;
        TreeNode<T> *right;
   
        TreeNode(T data) 
  		{ 
            this -> data = data; 
            left = NULL; 
            right = NULL; 
        }
   };
   
   
 ************************************************************/
#include<bits/stdc++.h>
#include<unordered_map>
TreeNode<int>*build(vector<int>&inorder,int instart,int inend,vector<int>&postorder,int poststart,int postend,unordered_map<int,int>&mp){
     if(instart>inend || poststart<postend){
          return NULL;
     }
     TreeNode<int>*root=new TreeNode<int>(postorder[poststart]);
     int inroot=mp[root->data];
     int numsright=inend-inroot;
          
     root->right=build(inorder,inroot+1,inend,postorder,poststart-1,poststart-numsright,mp);
     root->left=build(inorder,instart,inroot-1,postorder,poststart-numsright-1,postend,mp);
    
     return root;
}
TreeNode<int>* getTreeFromPostorderAndInorder(vector<int>& postorder, vector<int>& inorder) 
{
	// Write your code here.
     unordered_map<int,int>mp;
     int n=inorder.size();
     for(int i=0;i<n;i++)
     {
          mp[inorder[i]]=i;
     }
     return build(inorder,0,n-1,postorder,n-1,0,mp);

     
}

Q132
/*****************************************************

    Following is the Binary Tree node structure:
    
    class BinaryTreeNode {
        public : 
        T data;
        BinaryTreeNode<T> *left;
        BinaryTreeNode<T> *right;

        BinaryTreeNode(T data) {
            this -> data = data;
            left = NULL;
            right = NULL;
        }
        
        ~BinaryTreeNode() {
            if(left) 
                delete left;
            if(right) 
                delete right;
        }
    };

******************************************************/
bool identicalTrees(BinaryTreeNode<int>* root1, BinaryTreeNode<int>* root2) {
    // Write your code here.
     	 
    if(root1==NULL && root2==NULL){
      return true;
    }
    if (!root1 or !root2) {
      return false;
    }
    if(root1->data==root2->data){
      return (identicalTrees(root1->left,root2->right)&&identicalTrees(root1->right,root2->left));
    }
    return false;
}

bool isSymmetric(BinaryTreeNode<int>* root)
{
    // Write your code here.
    if(!root)return true; 
    BinaryTreeNode<int>*r1=root->left,*r2=root->right;

    if(root->left && root->right && r1->data==r2->data){
        return identicalTrees(r1,r2);


    }
    if (!r1 && !r2) {
      return true;
    }
    return false; 
}
Q133
#include <bits/stdc++.h> 
/************************************************************

    Following is the TreeNode class structure.

    template <typename T>
    class TreeNode {
        public:
        T data;
        TreeNode<T> *left;
        TreeNode<T> *right;

        TreeNode(T data) {
            this->data = data;
            left = NULL;
            right = NULL;
        }
    };

************************************************************/
void preorder(TreeNode<int>*&r,TreeNode<int>*root){
     if(root==NULL)return ;
     preorder(r,root->right);
     preorder(r,root->left);
     root->left=NULL;
     root->right=r;
     r=root;


}
TreeNode<int> *flattenBinaryTree(TreeNode<int> *root)
{
    // Write your code here.
    
    TreeNode<int>*r=NULL;
    preorder(r,root);
    return r;
    


}
Q134
#include <bits/stdc++.h> 
/************************************************************

    Following is the TreeNode class structure

    template <typename T>
    class TreeNode {
       public:
        T data;
        TreeNode<T> *left;
        TreeNode<T> *right;

        TreeNode(T data) {
            this->data = data;
            left = NULL;
            right = NULL;
        }
    };

************************************************************/

 

typedef TreeNode<int> * t;

void s(t r, t p, t l, bool& q, t& ans){

    if(!r){

        return;

    }

    if(r->data==l->data){

        r->left=p;

        q=1;

        ans=r;

        return;

    }

    s(r->left, r, l, q, ans);

    if(q){

      

            r->left=p;

       return;

    }

    s(r->right, r, l, q, ans);

    if(q){

       if(r->left){

           r->right=r->left;

       }

       else{

           r->right=NULL;

       }

            r->left=p;

            return;

       

    }

}

TreeNode<int> * invertBinaryTree(TreeNode<int> *r, TreeNode<int> *l)

{

    // Write your code here.

    bool q=0;

    t ans=NULL;

    s(r, NULL, l, q, ans);

    return ans; 

}
Q135
#include <bits/stdc++.h> 
/*************************************************************

    Following is the Binary Tree node structure

    class BinaryTreeNode
    {
    public :
        T data;
        BinaryTreeNode < T > *left;
        BinaryTreeNode < T > *right;

        BinaryTreeNode(T data) {
            this -> data = data;
            left = NULL;
            right = NULL;
        }
    };

*************************************************************/
void changeTree(BinaryTreeNode < int > * root) {
    // Write your code here.
    if(root==NULL)return;
    int child=0;
    if(root->left)child+=root->left->data;
    if(root->right)child+=root->right->data;
    if(child<root->data){
       if(root->left) root->left->data=root->data;
       else if(root->right) root->right->data=root->data;

    }else{
        root->data=child;
    }
    changeTree(root->left);
    changeTree(root->right);
    int tot=0;
    if(root->left)tot+=root->left->data;
    if(root->right)tot+=root->right->data;
    if(root->left || root->right)root->data=tot;


}  
Q136
#include <bits/stdc++.h> 
/*
    ----------------- Binary Tree node class for reference -----------------

    template <typename T>
    class BinaryTreeNode {
        public : 
            T data;
            BinaryTreeNode<T> *left;
            BinaryTreeNode<T> *right;
            BinaryTreeNode<T> *next;

            BinaryTreeNode(T data) {
                this -> data = data;
                left = NULL;
                right = NULL;
                next = NULL;
            }
    };
*/

void connectNodes(BinaryTreeNode< int > *root) {
    // Write your code here.
    BinaryTreeNode<int>*ans=root;
    if(root==NULL or root->left==NULL&&root->right==NULL)return ;

    queue<BinaryTreeNode<int>*>q;
    q.push(root);
    while(!q.empty()){
        int n=q.size();
        while(n--){
            auto p=q.front();
            q.pop();
            p->next=n?q.front():NULL;
            if(p->left)q.push(p->left);
            if(p->right)q.push(p->right);

        }

    } 

}
Q137
#include <bits/stdc++.h> 
/*
    Following is the Binary Tree node structure:

    class BinaryTreeNode {
    public : 
        T data;
        BinaryTreeNode<T> *left;
        BinaryTreeNode<T> *right;

        BinaryTreeNode(T data) {
            this -> data = data;
            left = NULL;
            right = NULL;
        }
    };
*/

bool searchInBST(BinaryTreeNode<int> *root, int x) {
    // Write your code here.
    if(root==NULL)return false;
    if(root->data==x)return true;
    if(root->data>x){
        searchInBST(root->left,x);
    }
    else{
        searchInBST(root->right,x);
    }
    
}
Q138
#include <bits/stdc++.h> 
/************************************************************

    Following is the TreeNode class structure

    template <typename T>
    class TreeNode {
       public:
        T val;
        TreeNode<T> *left;
        TreeNode<T> *right;
        
        TreeNode(T val) {
            this->val = val;
            left = NULL;
            right = NULL;
        }
    };

************************************************************/
TreeNode<int>*bst(vector<int>&arr,int left,int right){
    if(left>right)return NULL;
    int mid=(left+right)>>1;
    TreeNode<int>*node= new TreeNode<int>(arr[mid]);
    node->left=bst(arr,left,mid-1);
    node->right=bst(arr,mid+1,right);
    return node;
}

TreeNode<int>* sortedArrToBST(vector<int> &arr, int n)
{
    // Write your code here.
    if(arr.size()==0 )return NULL;
    return bst(arr,0,arr.size()-1);
    

}
Q139
#include <bits/stdc++.h> 
/*************************************************************

    Following is the Binary Tree node structure

    template <typename T>

    class TreeNode{
    public:
        T data;
        TreeNode<T> *left;
        TreeNode<T> *right;

        TreeNode(T data) {
            this->data = data;
            left = NULL;
            right = NULL;
        }
        ~TreeNode() {
            if (left){
                delete left;
            }
            if (right){
                delete right;
            }
        }
    };

*************************************************************/
TreeNode<int>*pre(vector<int>&arr,int left,int right)
{
    if(left>right)return NULL;
    TreeNode<int>*node=new TreeNode<int>(arr[left]);
    int mid=right;
    for(int i=left+1;i<=right;i++){
        if(arr[i]>arr[left]){
            mid=i-1;
            break;
        }
    }
    node->left=pre(arr,left+1,mid);
    node->right=pre(arr,mid+1,right);
    return node;

    
}

TreeNode<int>* preOrderTree(vector<int> &preorder){
    // Write your code here.
    if(preorder.size()==0)return NULL;
    return pre(preorder,0,preorder.size()-1);
    
}
Q140
#include <bits/stdc++.h> 
/*************************************************************
 
    Following is the Binary Tree node structure

    class BinaryTreeNode 
    {
    public : 
        T data;
        BinaryTreeNode<T> *left;
        BinaryTreeNode<T> *right;

        BinaryTreeNode(T data) {
            this -> data = data;
            left = NULL;
            right = NULL;
        }
    };

*************************************************************/
bool bst(BinaryTreeNode<int>*root,int minval,int maxval){
    if(root==NULL)return true;
    if(root->data<minval or root->data>maxval){
        return false;
    }
    return bst(root->left,minval,root->data) and bst(root->right,root->data,maxval);

    
    
}
bool validateBST(BinaryTreeNode<int> *root) {
    // Write your code here
   

    return bst(root,INT_MIN,INT_MAX);

}
Q141
#include <bits/stdc++.h> 
/************************************************************
    Following is the Binary Search Tree node structure
    
    template <typename T>
    class TreeNode {
        public :
        T data;
        TreeNode<T> *left;
        TreeNode<T> *right;

        TreeNode(T data) {
            this -> data = data;
            left = NULL;
            right = NULL;
        }

        ~TreeNode() {
            if(left)
                delete left;
            if(right)
                delete right;
        }
    };

************************************************************/

TreeNode<int>* LCAinaBST(TreeNode<int>* root, TreeNode<int>* p, TreeNode<int>* q)
{
	// Write your code here
    if(root==NULL)return NULL;
    if(root->data>p->data and root->data>q->data)
    {
        return LCAinaBST(root->left,p,q);
    }
    else if(root->data<p->data and root->data<q->data){
        return LCAinaBST(root->right,p,q);
       
    }
    else {
        return root;
    }
    

    





}

Q142
#include <bits/stdc++.h> 
/*************************************************************

    Following is the Binary Tree node structure

    template <typename T>

    class BinaryTreeNode
    {
    public :
        T data;
        BinaryTreeNode<T> *left;
        BinaryTreeNode<T> *right;

        BinaryTreeNode(T data) {
            this -> data = data;
            left = NULL;
            right = NULL;
        }

        ~BinaryTreeNode() {
            if (left)
            {
                delete left;
            }
            if (right)
            {
                delete right;
            }
        }
    };

*************************************************************/
void solve(BinaryTreeNode<int>*root,int key,int &pre,int &suc)
{
       if(root==nullptr)
        {
            return;
        }
       solve(root->left,key,pre,suc);
        if(root->data<key)
        {
            pre=root->data;
        }
        if(root->data>key and suc==-1)
        {
            suc=root->data;
        }
       solve(root->right,key,pre,suc);
      
}
pair<int,int> predecessorSuccessor(BinaryTreeNode<int>* root, int key)
{
    // Write your code here.
    int pre=-1;
int suc=-1;
    if(root==nullptr)
    {
      return {-1, -1};
    }
    solve(root,key,pre,suc);
    return {pre,suc};


  
}


Q143
#include <bits/stdc++.h> 
/************************************************************

    Following is the TreeNode class structure

    template <typename T>
    class TreeNode {
       public:
        T val;
        TreeNode<T> *left;
        TreeNode<T> *right;

        TreeNode(T val) {
            this->val = val;
            left = NULL;
            right = NULL;
        }
    };

************************************************************/

// int floorInBST(TreeNode<int> * root, int x)
// {
//     // Write your code here.
//     int pre=-1;
//      while(root!=NULL){
//         if(root->val==x){
//             pre=root->val;
//             return pre;

//         }
//         else if(root->val>x){
//             root=root->left;
//         }
//         else{
//             pre=root->val;
//             root=root->right;

//         }

//     }

    
//     return pre;
// }
void solve(TreeNode<int> *root, int x, int &ans){
    if(!root){
        return;
    }

    if(root->val > x){
        solve(root->left, x, ans);
    }
    else{
        ans = root->val;
        solve(root->right, x, ans);
    }
}

int floorInBST(TreeNode<int> * root, int x)
{
    int ans = -1;
    solve(root, x, ans);
    return ans;
}
Q144
#include <bits/stdc++.h> 
/************************************************************

    Following is the TreeNode class structure:

    class BinaryTreeNode {
    public:
        T data;
        BinaryTreeNode<T> *left;
        BinaryTreeNode<T> *right;
        
        BinaryTreeNode(T data) {
            this->data = data;
            left = NULL;
            right = NULL;
        }
        
        ~BinaryTreeNode() {
            if (left) {
              delete left;
            }
            if (right) {
              delete right;
            }
        }
    };

************************************************************/
void solve(BinaryTreeNode<int> *root, int x, int &ans){
    if(!root){
        return;
    }

    if(root->data < x){
        solve(root->right, x, ans);
        
    }
    else{
        
        ans=root->data;
        solve(root->left, x, ans);
    }
}
int findCeil(BinaryTreeNode<int> *root, int x){
    // Write your code here.
     int ans = -1;
    solve(root, x, ans);
    return ans;
}
Q145
#include <bits/stdc++.h> 
/************************************************************
    Following is the Binary Search Tree node structure
    
    template <typename T>
    class TreeNode {
        public :
        T data;
        TreeNode<T> *left;
        TreeNode<T> *right;

        TreeNode(T data) {
            this -> data = data;
            left = NULL;
            right = NULL;
        }

        ~TreeNode() {
            if(left)
                delete left;
            if(right)
                delete right;
        }
    };

************************************************************/
void rec(TreeNode<int>* root,int &k,int &ans)

{

    if(!root)

    return ;

    rec(root->right,k,ans);

    k--;

    if(k==0)

    {

        ans=root->data;

        return;

    }

    rec(root->left,k,ans);

}

int KthLargestNumber(TreeNode<int>* root, int k) 

{

    // Write your code here.

    int ans=-1;

    rec(root,k,ans);

    return ans;

}
Q146
#include <bits/stdc++.h> 
/************************************************************

    Following is the TreeNode class structure

    template <typename T>
    class TreeNode {
       public:
        T data;
        TreeNode<T> *left;
        TreeNode<T> *right;

        TreeNode(T data) {
            this->data = data;
            left = NULL;
            right = NULL;
        }
    };

************************************************************/
int solve(TreeNode<int>*root,int &k){
    if(root==NULL)return 0;
    int left=solve(root->left,k);
    if(left)return left;
    k--;
    if(k==0){
        return root->data;
    }
    int right=solve(root->right,k);
    return right;
}
int kthSmallest(TreeNode<int> *root, int k)
{
	//	Write the code here.
    return solve(root,k);
}
Q147
#include <bits/stdc++.h> 
/**********************************************************

    Following is the Binary Tree Node structure:

    template <typename T>
    class BinaryTreeNode {
        public: 
        T data;
        BinaryTreeNode<T> *left;
        BinaryTreeNode<T> *right;

        BinaryTreeNode(T data) {
            this->data = data;
            left = NULL;
            right = NULL;
        }

        ~BinaryTreeNode() {
            if (left)
                delete left;
            if (right)
                delete right;
        }
    };
***********************************************************/

class BSTIterator {

stack<BinaryTreeNode<int>*> st;

public:

    BSTIterator(BinaryTreeNode<int>* root,bool flag) {

        while(root)

        {

            st.push(root);

            if(flag)

              root=root->left;

            else

              root=root->right;

        }

    }

    

    int next(bool flag) {

        BinaryTreeNode<int>* temp=st.top();

        st.pop();

        BinaryTreeNode<int>* cur;

        if(flag)

          cur=temp->right;

        else

          cur=temp->left;

        while(cur)

        {

            st.push(cur);

            if(flag)

              cur=cur->left;

            else

              cur=cur->right;

        }

        return temp->data;

    }

    

    bool hasNext() {

        return !st.empty();

    }

};

 

bool pairSumBst(BinaryTreeNode<int> *root, int k)

{

    // Write your code here

    BSTIterator* l=new BSTIterator(root,true);

    BSTIterator* r=new BSTIterator(root,false);

 

    int i=l->next(true);

    int j=r->next(false);

    while(i<j)

    {

        if(i+j==k)

            return true;

        if(i+j<k)

            i=l->next(true);

        else

            j=r->next(false);

    }

    return false;

}
Q148
#include <bits/stdc++.h> 
/************************************************************

    Following is the TreeNode class structure

    template <typename T>
    class TreeNode {
       public:
        T data;
        TreeNode<T> *left;
        TreeNode<T> *right;

        TreeNode(T data) {
            this->data = data;
            left = NULL;
            right = NULL;
        }
    };

************************************************************/

class BSTiterator
{
     public: 
    stack<int> st;
    void inorder(TreeNode<int>* root)
    {
        if(root==NULL)
        return;

        inorder(root->right);
        st.push(root->data);
        inorder(root->left);
        return;
    }
    BSTiterator(TreeNode<int> *root)
    {
        // write your code here
         inorder(root);
    }

    int next()
    {
        // write your code here
        if(st.empty())
        return -1;
        else
        {
            int z=st.top();
            st.pop();
            return z;
        } 
    }

    bool hasNext()
    {
        // write your code here
        if(st.empty())
        return false;
        else
        return true;
    }
};


/*
    Your BSTIterator object will be instantiated and called as such:
    BSTIterator iterator(root);
    while(iterator.hasNext())
    {
       print(iterator.next());
    }
*/
Q149
#include <bits/stdc++.h> 
/************************************************************

    Following is the Binary Tree node structure
    
    template <typename T>
    class TreeNode {
        public :
        T data;
        TreeNode<T> *left;
        TreeNode<T> *right;

        TreeNode(T data) {
            this -> data = data;
            left = NULL;
            right = NULL;
        }

        ~TreeNode() {
            if(left)
                delete left;
            if(right)
                delete right;
        }
    };

************************************************************/

#include <bits/stdc++.h>

class NodeValue {
public:
  int minNode, maxNode, maxSize;

  NodeValue(int min, int max, int size) {
    minNode = min;
    maxNode = max;
    maxSize = size;
  }
};

NodeValue largestBSTSolve(TreeNode<int> *root) {
  if (!root)
    return NodeValue(INT_MAX, INT_MIN, 0);

  auto left = largestBSTSolve(root->left);
  auto right = largestBSTSolve(root->right);

  if (root->data > left.maxNode and root->data < right.minNode) // is a bst
    return NodeValue(min(left.minNode, root->data),
                     max(right.maxNode, root->data),
                     1 + left.maxSize + right.maxSize);

  return NodeValue(INT_MIN, INT_MAX,
                   max(left.maxSize, right.maxSize)); // not bst
}

int largestBST(TreeNode<int> *root) {
    return largestBSTSolve(root).maxSize;
}
Q150
/************************************************************

    Following is the TreeNode class structure

    template <typename T>
    class TreeNode {
       public:
        T data;
        TreeNode<T> *left;
        TreeNode<T> *right;

        TreeNode(T data) {
            this->data = data;
            left = NULL;
            right = NULL;
        }
    };

************************************************************/

#include <bits/stdc++.h>
using namespace std;

string serializeTree(TreeNode<int> *root) {
  if (!root)
    return "";
  string str;
  queue<TreeNode<int> *> q;
  q.push(root);

  while (!q.empty()) {
    int n = q.size();
    while (n--) {
      auto p = q.front();
      q.pop();

      if (!p) {
        str += "#,";
        continue;
      }

      str += to_string(p->data) + ",";
      q.push(p->left);
      q.push(p->right);
    }
  }

  return str;
}

TreeNode<int> *deserializeTree(string &str) {
  if (str.empty())
    return NULL;

  stringstream s(str);
  string temp;

  getline(s, temp, ',');
  TreeNode<int> *root = new TreeNode<int>(stoi(temp));

  queue<TreeNode<int> *> q;
  q.push(root);

  while (!q.empty()) {
    auto p = q.front();
    q.pop();

    getline(s, temp, ',');
    if (temp == "#")
      p->left = NULL;
    else {
      p->left = new TreeNode<int>(stoi(temp));
      q.push(p->left);
    }

    getline(s, temp, ',');
    if (temp == "#")
      p->right = NULL;
    else {
      p->right = new TreeNode<int>(stoi(temp));
      q.push(p->right);
    }
  }

  return root;
}


Q151
#include <bits/stdc++.h> 
/*************************************************************
 
    Following is the Binary Tree node structure

    class BinaryTreeNode 
    {
    public : 
        T data;
        BinaryTreeNode<T> *left;
        BinaryTreeNode<T> *right;

        BinaryTreeNode(T data) {
            this -> data = data;
            left = NULL;
            right = NULL;
        }
    };

*************************************************************/
void solve(BinaryTreeNode<int>* root,BinaryTreeNode<int>* &head,BinaryTreeNode<int>* &prev){

    if(root==NULL) return;

    solve(root->left,head,prev);

    if(prev==NULL){

        head=root;

        prev=root;

    }else{

        prev->right=root;

        root->left=prev;

        prev=prev->right;

    }

    solve(root->right,head,prev);

}

BinaryTreeNode<int>* BTtoDLL(BinaryTreeNode<int>* root) {

    // Write your code here

    BinaryTreeNode<int>* head=NULL;

    BinaryTreeNode<int>* prev=NULL;

    solve(root,head,prev);

    return head;

}

Q152
#include<queue>
vector<int> findMedian(vector<int> &arr, int n){
	
	// Write your code here 
	priority_queue<int>pmax;
	priority_queue<int,vector<int>,greater<int>>pmin;
	vector<int>ans;
	for(int i=0;i<n;i++)
	{
		if(pmax.empty() or pmax.top()>=arr[i]){
			pmax.push(arr[i]);
		}
		else{
			pmin.push(arr[i]);

		}
		 if(pmax.size()>pmin.size()+1)
		 {
			 pmin.push(pmax.top());
			 pmax.pop();
		 }
		 else if(pmin.size()>pmax.size()){
			 pmax.push(pmin.top());
			 pmin.pop();

		 }
		 if(pmax.size()>pmin.size()){
			 ans.push_back(pmax.top());
		 }
		 else{
			 ans.push_back((pmax.top()+pmin.top())/2);
		 }

	}
	return ans;
}
Q153
#include <bits/stdc++.h> 
class Kthlargest {
public:
    priority_queue<int, vector<int>, greater<int>> pq;
    int K;
    Kthlargest(int k, vector<int> &arr) {
       // Write your code here.
        K = k;
        for(auto &num : arr) {
            pq.push(num);
            if(pq.size() > K)
                pq.pop();
        }
    }

    void add(int num) {
        // Write your code here.
        pq.push(num);
        if(pq.size() > K)
            pq.pop();
    }

    int getKthLargest() {
       // Write your code here.
        return pq.top();
    }

};
Q154
#include <bits/stdc++.h> 
vector<int> countDistinctElements(vector<int> &arr, int k) 
{
    // Write your code here
    map<int,int>mp;
    for(int i=0;i<k;i++)
    {
        mp[arr[i]]++;
    }
    vector<int>ans;
    ans.push_back(mp.size());
    for(int i=1;i<arr.size()-k+1;i++){
        mp[arr[i-1]]--;
        mp[arr[i+k-1]]++;
        if(mp[arr[i-1]]==0){
            mp.erase(arr[i-1]);
        }
        ans.push_back(mp.size());
        
    }
    return ans;
	
}

Q155
#include <bits/stdc++.h> 
int kthLargest(vector<int>& arr, int size, int K)
{
	priority_queue<int ,vector<int>,greater<int>>pq;
	for(auto ele:arr){
		pq.push(ele);
		if(pq.size()>K)pq.pop();
	}
	return pq.top();
}
Q156
#include<bits/stdc++.h>
#include<queue>
// bool isvalid(vector<vector<int>>&image,int a, int newColor,int i,int j,int m ,int n)
// {
//     if(i<0 or j<0 or i>=m or j>=n or image[i][j]==newColor or image[i][j]!=a)
//     {
//         return false;
//     }
//     return true;
// }
// vector<vector<int>> floodFill(vector<vector<int>> &image, int x, int y, int newColor)
// {
//     // Write your code here.
//     int m=image.size(),n=image[0].size();
//     queue<pair<int,int>>q;
//     int a=image[x][y];
//     q.push({x,y});
//     while(!q.empty()){
//         pair<int,int>temp=q.front();
//         q.pop();
//         int i=temp.first;
//         int j=temp.second;
//         image[i][j]=newColor;

      
//           if(isvalid(image,a,newColor,i-1,j,m,n)){
//               q.push({i-1,j});}
//           if(isvalid(image,a,newColor,i+1,j,m,n)){
//               q.push({i+1,j});}
//           if(isvalid(image,a,newColor,i,j-1,m,n)){
//               q.push({i,j-1});}
//           if(isvalid(image,a,newColor,i,j+1,m,n)){
//               q.push({i,j+1});}
        
//     }
//     return image;


// }
void solve(vector<vector<int>>&image,int x,int y,int newColor,int a,int m,int n){
     if(x<0 or y<0 or x>=m or y>=n or  image[x][y]!=a)
    {
        return;
    }
    image[x][y]=newColor;
    solve(image,x-1,y,newColor,a,m,n);
    solve(image,x+1,y,newColor,a,m,n);
    solve(image,x,y-1,newColor,a,m,n);
    solve(image,x,y+1,newColor,a,m,n);


}
vector<vector<int>> floodFill(vector<vector<int>> &image, int x, int y, int newColor){
    int a=image[x][y];
    if(a==newColor){
        return image;
    }
    int m=image.size(),n=image[0].size();
    solve(image,x,y,newColor,a,m,n);
    return image;

}



Q157
#include <bits/stdc++.h> 
/***************************************************************************

	Class for graph node is as follows:

	class graphNode
	{
		public:
    		int data;
    	vector<graphNode *> neighbours;
    	graphNode()
    	{
        	data = 0;
        	neighbours = vector<graphNode *>();
    	}

    	graphNode(int val)
    	{
        	data = val;
        	neighbours = vector<graphNode *>();
    	}

    	graphNode(int val, vector<graphNode *> neighbours)
    	{
        	data = val;
        	this->neighbours = neighbours;
    	}
	};

******************************************************************************/

graphNode *cloneGraph(graphNode *node)
{
    // Write your code here.
	graphNode*copy;
	unordered_map<graphNode*,graphNode*>mp;
	if(node){
		copy=new graphNode(node->data);
		mp[node]=copy;

	}
	queue<graphNode*>q;
	q.push(node);
	while(!q.empty()){
		auto temp=q.front();
		q.pop();
		for(auto it:temp->neighbours){
			if(mp.find(it)==mp.end()){
				graphNode* c=new graphNode(it->data);
				mp[it]=c;
				q.push(it);
			}
			mp[temp]->neighbours.push_back(mp[it]);
		}
	}
	return copy;
}
Q158

void dfs(int node,vector<int>adj[],vector<int>&vis,vector<int>&ls){

       vis[node]=1;

       ls.push_back(node);

       for(auto it:adj[node]){

           if(!vis[it]){

                dfs(it,adj,vis,ls);

           }

       }

}

vector<vector<int>> depthFirstSearch(int V, int E, vector<vector<int>> &edges)

{

          vector<int>adj[V];

          for(int i=0;i<edges.size();i++){

             int u=edges[i][0];

             int v=edges[i][1];

             adj[u].push_back(v);

             adj[v].push_back(u);

          }

       vector<int>vis(V,0);

       vector<vector<int>>ans;

      for(int i=0;i<V;i++){

           if(!vis[i]){

               vector<int>ls;

               dfs(i,adj,vis,ls);

               ans.push_back(ls);

           }

      }

      return ans;

}
Q159
#include <bits/stdc++.h> 
vector<int> BFS(int vertex, vector<pair<int, int>> edges)
{
    // Write your code here
    vector<int>adj[vertex];
    for(int i=0;i<edges.size();i++)
    {
        int u=edges[i].second;
        int v=edges[i].first;
        adj[u].push_back(v);
        adj[v].push_back(u);
    }
      for(int i = 0; i < vertex; i++){

        sort(adj[i].begin(), adj[i].end());

    }
    vector<int>ls;
    
    int vis[vertex]={0};
    for(int i=0;i<vertex;i++){
        
    queue<int>q;
    if(vis[i]==0){
    q.push(i);
    vis[i]=1;
    while(!q.empty()){
        int node=q.front();
        q.pop();
        ls.push_back(node);
        for(auto it:adj[node]){
            if(vis[it]!=1){
                q.push(it);
                vis[it]=1;
                
            }
        }
    }
    }
    }
    return ls;

}
Q160
#include<queue>
bool detect(int vis[],vector<int>adj[],int src){
    vis[src]=1;
    queue<pair<int,int>> q;
    q.push({src,-1});
    while(!q.empty()){
        int node=q.front().first;
        int parent=q.front().second;
        q.pop();
        for(auto it:adj[node]){
            if(!vis[it]){
                vis[it]=1;
                q.push({it,node});
            }
            else if(parent!=it){
                return true;
            }
        }
    }
    return false;

}
string cycleDetection (vector<vector<int>>& edges, int n, int m)
{
    // Write your code here.
    string y="Yes",no="No";
    vector<int>adj[n+1];
    for(int i=0;i<m;i++){
        int v=edges[i][0];
        int u=edges[i][1];
        adj[v].push_back(u);
        adj[u].push_back(v);
    }
    int vis[n+1]={0};
    for(int i=1;i<=n;i++){
        if(!vis[i]){
            if(detect(vis,adj,i))return y;
        }
    }
    return no;

}





Q161
#include<bits/stdc++.h>
bool dfs(int i,vector<int>& vis,vector<int>& pathvis,vector<list<int>>& adj)
{
  vis[i]=1;
  pathvis[i] = 1;

  for(auto nb:adj[i])
  {
    if (vis[nb] == 0) {
      if (dfs(nb, vis, pathvis, adj) == true)
        return true;
    }

    else if (pathvis[nb] == 1)
      return true;
  }
  pathvis[i] = 0;
  return false;
}
int detectCycleInDirectedGraph(int n, vector < pair < int, int >> & edges) {
  // Write your code here.
  vector<list<int>> adj(n+1);

  for(int i=0;i<edges.size();i++)
  {
    int u = edges[i].first;
    int v = edges[i].second;

    adj[u].push_back(v);
  }

  vector<int> vis(n+1,0);
  vector<int>pathvis(n+1,0);

  for(int i=1;i<=n;i++)
  {
    //pathvis={0};
    if (vis[i] == 0) {
      if (dfs(i, vis, pathvis, adj))
        return 1;
    }
  }
  return 0;
}
Q162
#include <bits/stdc++.h> 
#include<queue>
vector<int> topologicalSort(vector<vector<int>> &edges, int v, int e)  {
    // Write your code here
    vector<int>adj[v];
    for(int i=0;i<e;i++)
    {
        int a=edges[i][0];
        int b=edges[i][1];
        adj[a].push_back(b);
    }
    int indegree[v]={0};
    for(int i=0;i<v;i++){
      for (auto it : adj[i]) {
        indegree[it]++;
      }
    }
    queue<int>q;
    for(int i=0;i<v;i++){
        if(indegree[i]==0){
            q.push(i);
        }
    }
    vector<int>toposort;
    while(!q.empty()){
        int node=q.front();
        q.pop();
        toposort.push_back(node);
        for(auto it:adj[node]){
            indegree[it]--;
            if(indegree[it]==0){
                q.push(it);
            }
        }
    }
    return toposort;


}
Q163
#include<bits/stdc++.h>
#include<queue>
void bfs(int row,int col,int **arr,int n ,int m,int r[],int c[]){

   queue<pair<int,int>>q;
   q.push({row,col});
   
   while(!q.empty()){
      int one=q.front().first;
      int two=q.front().second;
      q.pop();
      arr[one][two]=2;
      
      for(int i=0;i<8;i++){
         int nr=one+r[i];
         int nc=two+c[i];
         if(nr>=0 and nc>=0 and nr<n and nc<m and arr[nr][nc]==1){
            q.push({nr,nc});
         }
         
      }

   }

}
int getTotalIslands(int** arr, int n, int m)
{
   // Write your code here.
  
   int count=0;
   int r[8]={-1,-1,-1,0,0,1,1,1};
   int c[8]={-1,0,1,-1,1,-1,0,1};
   for(int i=0;i<n;i++){
      for(int j=0;j<m;j++){
         if(arr[i][j]==1){
        
            bfs(i,j,arr,n,m,r,c);
            count++;
         }
      }
   }
   return count;
}

Q164
#include<queue>
bool bfs(int i,vector<int>adj[],vector<int>&vis){
	queue<pair<int,int>>q;
        q.push({i, 0});
        while(!q.empty()){
		int node=q.front().first;
		int color=q.front().second;
		q.pop();
		for(auto it:adj[node]){
			if(vis[it]==-1){
				vis[it]= (!color);
				q.push({it,!color});
			}
			else if(vis[it]!=(!color)){
				return false;
		
			}
		}

	}
	return true;
}
bool isGraphBirpatite(vector<vector<int>> &edges) {
	// Write your code here.
	
	int n=edges.size(),m=edges[0].size();
	vector<int>adj[n];
	for(int i=0;i<n;i++)
	{
		for(int j=0;j<m;j++)
		{
			if(edges[i][j])
			{
				adj[i].push_back(j);
				adj[j].push_back(i);

			}
		}
	}
	vector<int>vis(n,-1);
	for(int i=0;i<n;i++)
	{
		if(vis[i]==-1){
			vis[i]=0;
			if(!bfs(i,adj,vis)){
				return false;
			}
		}
	}
	return true;
}
Q165
#include<bits/stdc++.h>
using namespace std;

void topologicalSort(vector<int> adj[], int S, bool visited[], stack<int> &st) {
    visited[S] = true;
    for(int v : adj[S]) {
        if(!visited[v]) topologicalSort(adj,v,visited,st);
    }
    st.push(S);
}

void DFS(vector<int> adj[], int s, bool visited[], vector<int> &ans) {
    visited[s] = true;
    ans.push_back(s);
    for(int v : adj[s]) {
        if(!visited[v]) DFS(adj,v,visited,ans);
    }
}

vector<vector<int>> stronglyConnectedComponents(int n, vector<vector<int>> &edges)
{   
    vector<int>adj1[n],adj2[n];
    bool visited[n] = {0};
    stack<int> st;
    vector<vector<int>> res;
    
    for(auto i: edges) 
        adj1[i[0]].push_back(i[1]);
    
    for(int i = 0; i < n; i++)
        if(!visited[i]) topologicalSort(adj1, i, visited, st);

    for(auto i: edges) 
        adj2[i[1]].push_back(i[0]); 
    fill(visited, visited+n, 0);

    while(!st.empty()) {
        int u = st.top();
        st.pop();
        vector<int> ans;
        if(!visited[u]) {DFS(adj2,u,visited,ans); res.push_back(ans);}
    }
    return res;
}
Q166
#include <bits/stdc++.h> 
vector<int> dijkstra(vector<vector<int>> &vec, int vertices, int edges, int source) {
    // Write your code here.
    vector<int> dis(vertices, INT_MAX);
    vector<pair<int, int>> adjList[vertices];
    priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq; // first min heap
    pq.push({0, 0});
    dis[0] = 0;
    for(auto ele : vec){
        adjList[ele[0]].push_back({ele[1], ele[2]});
        adjList[ele[1]].push_back({ele[0], ele[2]});
    }
    while(!pq.empty()){
        pair<int, int> node = pq.top();
        pq.pop();
        vector<pair<int, int>> nodes = adjList[node.second];
        for(auto ele: nodes){
            int ndis = node.first + ele.second;
            if(ndis < dis[ele.first]){
                dis[ele.first] = ndis;
                pq.push({ndis, ele.first});
            }
        }
        
    }
    
    
    return dis;
    
    
}

Q167

#include <bits/stdc++.h> 
int bellmonFord(int n, int m, int src, int dest, vector<vector<int>> &edges) {
      
           vector<int>dist(n+1,1e9);
           dist[src]=0;
         for(int i=0;i<n-1;++i){
             for(auto it:edges){
             int u=it[0];
             int v=it[1];
             int wt=it[2];
        if(dist[u] !=1e9 && dist[u]+wt<dist[v]){
            dist[v]=dist[u]+wt;
        }
         }
         }
      return dist[dest];
       
}
Q168
int floydWarshall(int n, int m, int src, int dest, vector<vector<int>> &edges) {
    // Write your code here.
    vector<vector<int>>mat(n,vector<int>(n,1e9));
    for(int i=0;i<n;i++)
    {
        mat[i][i]=0;

    }
    for(auto i:edges){
        int u=i[0]-1,v=i[1]-1,wt=i[2];
        mat[u][v]=wt;
    }
    for(int k=0;k<n;k++)
    {
        for(int i=0;i<n;i++)
        {
            for(int j=0;j<n;j++){
                if(mat[i][k]!=1e9 and mat[k][j]!=1e9)
                {
                    mat[i][j]=min(mat[i][j],mat[i][k]+mat[k][j]);
                }
            }
        }
    }
    return mat[src-1][dest-1];

}
Q169
#include <bits/stdc++.h> 
vector<pair<pair<int, int>, int>> calculatePrimsMST(int n, int m, vector<pair<pair<int, int>, int>> &g)
{
    // Write your code here.
    
    priority_queue< pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;

    unordered_map<int, list<pair<int, int>>> adj;

    for(int i =0;i<m;i++){

      int u = g[i].first.first;

      int v = g[i].first.second;

      int w = g[i].second;

 

      adj[u].push_back({v,w});

      adj[v].push_back({u,w});

    }

 

    vector<int> key(n+1, INT_MAX);

    vector<int> parent(n+1, -1);

    vector<bool> mst(n+1, false);

 

    key[1] = 0;

    parent[1] = -1;

    pq.push({0,1});

 

    

    //for(int i= 1;i<n;i++ ){

      while(!pq.empty()){

        int mini = INT_MAX;

        int u;

        /*for(int v =1;v<=n;v++){

            if(mst[v] == false &&  key[v] < mini){

                mini = key[v];

                u =v;

            }

        }*/

        u = pq.top().second;

        mini = pq.top().first;

        pq.pop();

    

    if(mst[u]){

      continue;

    }

    mst[u] = true;

 

    for(auto n: adj[u]){

        int v = n.first;

        int w = n.second;

 

        if (mst[v] == false && w < key[v]) {

          key[v] = w;

          pq.push({w,v});

          parent[v] = u;

        }

    }

    }

 

    vector<pair<pair<int, int>, int>> result;

    for(int i =2;i<=n;i++){

      result.push_back({{parent[i], i}, key[i]});

    }

    return result;
}
Q170

#include <bits/stdc++.h> 
class DisjointSet{
private:
      vector<int>rank,size,parent;
public:
  DisjointSet(int n){
	   rank.resize(n+1,0);
       size.resize(n+1,1);
	   parent.resize(n+1);
	   for(int i=0;i<=n;++i){
		   parent[i]=i;
	   }
  }
int findPar(int node){
	  if(node==parent[node]){
		  return node;
	  }
	return parent[node]=findPar(parent[node]);
}
 void UnionByRank(int u ,int v){
	  int ulp_u=findPar(u);
	  int ulp_v=findPar(v);
	if(ulp_u==ulp_v){
		return ;
	}
	if(rank[ulp_u]>rank[ulp_v]){
		parent[ulp_v]=ulp_u;
	}else if(rank[ulp_u]<rank[ulp_v]){
		parent[ulp_u]=ulp_v;
	}else{
		parent[ulp_u]=ulp_v;
		rank[ulp_v]++;
	}
 }
void UnionBySize(int u ,int v){
	int ulp_u=findPar(u);
	int ulp_v=findPar(v);
	if(ulp_u==ulp_v){
		return ;
	}
	if(size[ulp_v]<size[ulp_u]){
		parent[ulp_v]=ulp_u;
		size[ulp_v]+=size[ulp_u];
	}else{
		parent[ulp_u]=ulp_v;
		size[ulp_u]+=size[ulp_u];
	}
  }
};
bool compare(vector<int>const &a , vector<int> const &b){
	  return a[2]<b[2];
}
int kruskalMST(int n, int m, vector<vector<int>> &graph) {
	    // vector<pair<int,pair<int,int>>>edges;
	    // for(auto it:graph){
		// 	int u=it[0];
		// 	int v=it[1];
		// 	int wt=it[2];
		// edges.push_back({wt,{u,v}});
		// }
		// sort(edges.begin(),edges.end());
		sort(graph.begin(),graph.end(),compare);
		int mstSum=0;
		DisjointSet ds(n);
	 for(auto it:graph){
		 int wt=it[2];
		 int u=it[0];
		 int v=it[1];
	if(ds.findPar(u) != ds.findPar(v)){
		 mstSum+=wt;
		 ds.UnionByRank(u,v);
	}
	 }
	 return mstSum;
}
Q171
#include <bits/stdc++.h> 
int maximumProduct(vector<int> &nums, int n)
{
	// Write your code here
	 int prod1 = nums[0],prod2 = nums[0],result = nums[0];
    
    for(int i=1;i<n;i++) {
        int temp = max({nums[i],prod1*nums[i],prod2*nums[i]});
        prod2 = min({nums[i],prod1*nums[i],prod2*nums[i]});
        prod1 = temp;
        
        result = max(result,prod1);
    }
    
    return result;
}

Q172
#include<bits/stdc++.h>
using namespace std;
/*int func(int arr[],int n,vector<vector<int>>&dp,int ind,int prev_ind)
{
    if(ind==n)return 0;
    if (dp[ind][prev_ind+1] != -1) {
      return dp[ind][prev_ind + 1];
    }
    int notake=0+func(arr,n,dp,ind+1,prev_ind);
    int take=0;
    if(arr[ind]>arr[prev_ind] || prev_ind==-1)
    {
        take=1+func(arr,n,dp,ind+1,ind);
    }
    return dp[ind][prev_ind+1]=max(take,notake);
}
int longestIncreasingSubsequence(int arr[], int n)
{
    // Write Your Code here
    vector<vector<int>>dp(n,vector<int>(n+1,-1));
    return func(arr,n,dp,0,-1);
}*/
//binary search
int longestIncreasingSubsequence(int arr[], int n){
      vector<int>temp;
    temp.push_back(arr[0]);
    int len=1;
    for(int i=1;i<n;i++){
        if(arr[i]>temp.back()){
            temp.push_back(arr[i]);
            len++;
        }
        else{
            int ind =lower_bound(temp.begin(),temp.end(),arr[i])-temp.begin();
            temp[ind]=arr[i];
        }
    }
    return len;

}

Q173








